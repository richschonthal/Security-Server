XXHEYFile: ChangeNotificationContextObj.cppYYHEY

0001	//--------------------------------------------------------------------------------
0002	// Copyright (c) 2001 @COMPANY
0003	// Created...: 6/8/01
0004	// Author....: Rich Schonthal
0005	//--------------------------------------------------------------------------------
0006	#include "stdafx.h"
0007	#include "ChangeNotificationContextObj.h"
0008	#ifdef _DEBUG
0009	#undef THIS_FILE
0010	static char THIS_FILE[]=__FILE__;
0011	#define new DEBUG_NEW
0012	#endif
0013	//--------------------------------------------------------------------------------
0014	ReadDirectoryChangesWType CChangeNotificationContextObj::m_pReadDirectoryChangesW =
0015		(ReadDirectoryChangesWType) GetProcAddress(GetModuleHandle("kernel32.dll"), "ReadDirectoryChangesW");
0016	//--------------------------------------------------------------------------------
0017	CChangeNotificationContextObj::CChangeNotificationContextObj()
0018			: m_event(FALSE, TRUE)
0019			, m_pTarget(NULL)
0020			, m_bWatchSubDir(false)
0021			, m_nFilter(0)
0022		{
0023		}
0024	//--------------------------------------------------------------------------------
0025	CChangeNotificationContextObj::~CChangeNotificationContextObj()
0026		{
0027		}
ZZHEYXXHEYFile: ChangeNotificationContextObj.hYYHEY

0028	//--------------------------------------------------------------------------------
0029	//
0030	// Copyright (c) 2001 @COMPANY
0031	//
0032	// Programming by Rich Schonthal
0033	//
0034	//--------------------------------------------------------------------------------
0035	#ifndef _CHANGENOTIFICATIONCONTEXTOBJ_H_
0036	#define _CHANGENOTIFICATIONCONTEXTOBJ_H_
0037	//--------------------------------------------------------------------------------
0038	#include <Handle.h>
0039	//--------------------------------------------------------------------------------
0040	class CSystemObject;
0041	class CChangeNotificationObj;
0042	class CFileChangeNotificationObj;
0043	//--------------------------------------------------------------------------------
0044	typedef BOOL (__stdcall *ReadDirectoryChangesWType)(
0045	    IN HANDLE hDirectory,
0046	    IN OUT LPVOID lpBuffer,
0047	    IN DWORD nBufferLength,
0048	    IN BOOL bWatchSubtree,
0049	    IN DWORD dwNotifyFilter,
0050	    OUT LPDWORD lpBytesReturned,
0051	    IN LPOVERLAPPED lpOverlapped,
0052	    IN LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
0053	    );
0054	//--------------------------------------------------------------------------------
0055	class CChangeNotificationContextObj
0056		{
0057		friend class CChangeNotificationThread;
0058		protected:
0059			CEvent m_event;
0060			CSystemObject* m_pTarget;
0061			int m_nMessageId;
0062			static ReadDirectoryChangesWType m_pReadDirectoryChangesW;
0063			bool m_bWatchSubDir;
0064			DWORD m_nFilter;
0065		public:
0066			CChangeNotificationContextObj();
0067			virtual ~CChangeNotificationContextObj();
0068			CEvent& GetEvent();
0069			CSystemObject* GetTarget();
0070			int GetMessageId();
0071			virtual LPCTSTR GetPath() const;
0072			virtual bool IsValid();
0073			virtual bool IsChangeReady();
0074			virtual bool PostChanges();
0075			virtual bool GetNextChange();
0076		};
0077	//--------------------------------------------------------------------------------
0078	inline CEvent& CChangeNotificationContextObj::GetEvent() { return m_event; }
0079	inline CSystemObject* CChangeNotificationContextObj::GetTarget() { return m_pTarget; }
0080	inline int CChangeNotificationContextObj::GetMessageId() { return m_nMessageId; }
0081	inline LPCTSTR CChangeNotificationContextObj::GetPath() const { return NULL; }
0082	inline bool CChangeNotificationContextObj::IsValid() { return false; }
0083	inline bool CChangeNotificationContextObj::IsChangeReady() { return false; }
0084	inline bool CChangeNotificationContextObj::PostChanges() { return false; }
0085	inline bool CChangeNotificationContextObj::GetNextChange() { return false; }
0086	//--------------------------------------------------------------------------------
0087	class CFileChangeNotificationContextObj : public CChangeNotificationContextObj
0088		{
0089		private:
0090			CHandle m_hDir;
0091			LPCTSTR m_pPath;
0092			// for the overlapped result
0093			OVERLAPPED m_overlapped;
0094			CHandle m_hCompletionPort;
0095			enum { BUFFER_SIZE = 524288, BUFFER_BLOCK_SIZE = 4096 };
0096			UCHAR m_pBuffer[BUFFER_SIZE];
0097			int m_nCurBufIndex;
0098			DWORD m_nSize;
0099			UCHAR* m_pBase;
0100			OVERLAPPED* m_pOverlap;
0101			CFileChangeNotificationObj* m_pPrevRenameObj;
0102		public:
0103			CFileChangeNotificationContextObj();
0104			virtual ~CFileChangeNotificationContextObj();
0105			bool Create(LPCTSTR pPath, bool bWatchSubDir, DWORD nFilter, CSystemObject* pTarget, int nMsg);
0106			virtual LPCTSTR GetPath() const;
0107			virtual bool IsValid();
0108			virtual bool IsChangeReady();
0109			virtual bool PostChanges();
0110			virtual bool GetNextChange();
0111		};
0112	//--------------------------------------------------------------------------------
0113	class CRegChangeNotificationContextObj : public CChangeNotificationContextObj
0114		{
0115		private:
0116			HKEY m_hKey;
0117		public:
0118			CRegChangeNotificationContextObj();
0119			virtual ~CRegChangeNotificationContextObj();
0120			bool Create(HKEY, bool bWatchSubKeys, DWORD nFilter, CSystemObject* pTarget, int nMsg);
0121			virtual bool IsValid();
0122			virtual bool IsChangeReady();
0123			virtual bool PostChanges();
0124			virtual bool GetNextChange();
0125		};
0126	//--------------------------------------------------------------------------------
0127	inline bool CRegChangeNotificationContextObj::IsValid() { return m_hKey != NULL; }
0128	inline bool CRegChangeNotificationContextObj::IsChangeReady() { return true; }
0129	inline bool CRegChangeNotificationContextObj::GetNextChange()
0130		{
0131		m_event.ResetEvent();
0132		return ::RegNotifyChangeKeyValue(m_hKey, m_bWatchSubDir, m_nFilter, m_event, TRUE) == ERROR_SUCCESS;
0133		}
0134	#endif // _CHANGENOTIFICATIONCONTEXTOBJ_H_
ZZHEYXXHEYFile: ChangeNotificationDirThread.cppYYHEY

0135	//--------------------------------------------------------------------------------
0136	// Copyright (c) 2001 @COMPANY
0137	// Created...: 6/9/01
0138	// Author....: Rich Schonthal
0139	//--------------------------------------------------------------------------------
0140	#include "stdafx.h"
0141	#include "ChangeNotificationDirThread.h"
0142	#ifdef _DEBUG
0143	#undef THIS_FILE
0144	static char THIS_FILE[]=__FILE__;
0145	#define new DEBUG_NEW
0146	#endif
0147	//--------------------------------------------------------------------------------
0148	CChangeNotificationDirThread::CChangeNotificationDirThread(CChangeNotificationSubSystem* pParent)
0149			: CThreadObject(pParent)
0150			, m_pSubSystem(pParent)
0151		{
0152		}
0153	//--------------------------------------------------------------------------------
0154	CChangeNotificationDirThread::~CChangeNotificationDirThread()
0155		{
0156		}
0157	//--------------------------------------------------------------------------------
0158	void CChangeNotificationDirThread::OnMessage(UINT nMsg, WPARAM wparam, LPARAM lparam)
0159		{
0160		switch(nMsg)
0161			{
0162			case CChangeNotificationSubSystem::MsgChangeNotify:
0163				{
0164				m_pSubSystem->AddToQueue((FILE_NOTIFY_INFORMATION*) wparam, (int) lparam);
0165				break;
0166				}
0167			}
0168		}
ZZHEYXXHEYFile: ChangeNotificationDirThread.hYYHEY

0169	//--------------------------------------------------------------------------------
0170	// Copyright (c) 2001 @COMPANY
0171	// Created...: 6/8/01
0172	// Author....: Rich Schonthal
0173	//--------------------------------------------------------------------------------
0174	#if !defined(AFX_CHANGENOTIFICATIONDIRTHREAD_H__1A4AB94F_5C82_11D5_B191_00A0CC271D0D__INCLUDED_)
0175	#define AFX_CHANGENOTIFICATIONDIRTHREAD_H__1A4AB94F_5C82_11D5_B191_00A0CC271D0D__INCLUDED_
0176	#if _MSC_VER > 1000
0177	#pragma once
0178	#endif // _MSC_VER > 1000
0179	//--------------------------------------------------------------------------------
0180	#include <Directory.h>
0181	#include <Handle.h>
0182	#include "ThreadObject.h"
0183	#include "ChangeNotificationSubSystem.h"
0184	//--------------------------------------------------------------------------------
0185	class CChangeNotificationDirThread : public CThreadObject
0186		{
0187		DECLARE_THREADCLASS(CChangeNotificationSubSystem, CSystem);
0188		protected:
0189			CChangeNotificationSubSystem* m_pSubSystem;
0190		public:
0191			CChangeNotificationDirThread(CChangeNotificationSubSystem*);
0192			virtual ~CChangeNotificationDirThread();
0193			virtual void OnMessage(UINT, WPARAM, LPARAM);
0194		};
0195	#endif // !defined(AFX_CHANGENOTIFICATIONDIRTHREAD_H__1A4AB94F_5C82_11D5_B191_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: ChangeNotificationObj.hYYHEY

0196	//--------------------------------------------------------------------------------
0197	//
0198	// Copyright (c) 2001 @COMPANY
0199	//
0200	// Programming by Rich Schonthal
0201	//
0202	//--------------------------------------------------------------------------------
0203	#ifndef _CHANGENOTIFICATIONOBJ_H_
0204	#define _CHANGENOTIFICATIONOBJ_H_
0205	//--------------------------------------------------------------------------------
0206	#include <Registry.h>
0207	#include <FileNotifyInformation.h>
0208	//--------------------------------------------------------------------------------
0209	class CChangeNotificationObj
0210		{
0211		private:
0212			LPCTSTR m_pPath;
0213		public:
0214			CChangeNotificationObj(LPCTSTR pPath);
0215			LPCTSTR GetPath() const;
0216			enum eNotifyType
0217				{
0218				NotifyUnknown,
0219				NotifyFile,
0220				NotigyRegistry
0221				};
0222			// poor mans rtti
0223			virtual eNotifyType GetNotificationType() = 0;
0224		};
0225	//--------------------------------------------------------------------------------
0226	class CFileChangeNotificationObj : public CFileNotifyInformation, public CChangeNotificationObj
0227		{
0228		public:
0229			LPCTSTR m_pOldFilename;
0230		public:
0231			CFileChangeNotificationObj(const FILE_NOTIFY_INFORMATION*, LPCTSTR pPath);
0232			virtual eNotifyType GetNotificationType();
0233		};
0234	//--------------------------------------------------------------------------------
0235	class CRegChangeNotificationObj : public CChangeNotificationObj
0236		{
0237		private:
0238			HKEY m_hKey;
0239		public:
0240			CRegChangeNotificationObj(HKEY);
0241			virtual eNotifyType GetNotificationType();
0242			const HKEY GetRegKey() const;
0243		};
0244	//--------------------------------------------------------------------------------
0245	inline CChangeNotificationObj::CChangeNotificationObj(LPCTSTR p) : m_pPath(p) {}
0246	inline LPCTSTR CChangeNotificationObj::GetPath() const { return m_pPath; }
0247	//--------------------------------------------------------------------------------
0248	inline CFileChangeNotificationObj::CFileChangeNotificationObj(const FILE_NOTIFY_INFORMATION* pInfo, LPCTSTR pPath)
0249			: CFileNotifyInformation(pInfo)
0250			, CChangeNotificationObj(pPath)
0251			, m_pOldFilename(NULL)
0252		{
0253		}
0254	inline CChangeNotificationObj::eNotifyType CFileChangeNotificationObj::GetNotificationType() { return NotifyFile; }
0255	//--------------------------------------------------------------------------------
0256	inline CRegChangeNotificationObj::CRegChangeNotificationObj(HKEY hKey)
0257		: CChangeNotificationObj(NULL) {}
0258	inline CChangeNotificationObj::eNotifyType CRegChangeNotificationObj::GetNotificationType() { return NotigyRegistry; }
0259	inline const HKEY CRegChangeNotificationObj::GetRegKey() const { return m_hKey; }
0260	#endif //_CHANGENOTIFICATIONOBJ_H_
ZZHEYXXHEYFile: ChangeNotificationSubSystem.cppYYHEY

0261	//--------------------------------------------------------------------------------
0262	// Copyright (c) 2001 @COMPANY
0263	// Created...: 6/9/01
0264	// Author....: Rich Schonthal
0265	//--------------------------------------------------------------------------------
0266	//--------------------------------------------------------------------------------
0267	#include "stdafx.h"
0268	#include "ChangeNotificationSubSystem.h"
0269	#include "ChangeNotificationThread.h"
0270	#include "ChangeNotificationDirThread.h"
0271	#include <Directory.h>
0272	//--------------------------------------------------------------------------------
0273	IMPLEMENT_DYNAMIC(CChangeNotificationSubSystem, CSubSystem)
0274	/*
0275	//--------------------------------------------------------------------------------
0276	void  DestructElements<CFileNotifyInformation*>(CFileNotifyInformation** pElements, int nCount)
0277		{
0278		for(int i = 0; i < nCount; i++)
0279			delete *pElements;
0280		}
0281	*/
0282	//--------------------------------------------------------------------------------
0283	CChangeNotificationSubSystem::CChangeNotificationSubSystem(CSystem* pParent)
0284			: CThreadPoolSubSystem(pParent)
0285		{
0286		AddThread(RUNTIME_CLASS(CChangeNotificationThread));
0287		}
0288	//--------------------------------------------------------------------------------
0289	CChangeNotificationSubSystem::~CChangeNotificationSubSystem()
0290		{
0291		}
0292	//--------------------------------------------------------------------------------
0293	bool CChangeNotificationSubSystem::AddWatch(LPCTSTR pPath, CSystemObject* pTarget, int nMsgId, bool bWatchSubDir, DWORD nFilter)
0294		{
0295		CFileChangeNotificationContextObj* pContext = new CFileChangeNotificationContextObj;
0296		if(! pContext->Create(pPath, bWatchSubDir, nFilter, pTarget, nMsgId))
0297			{
0298			delete pContext;
0299			return false;
0300			}
0301		QueueContext((CChangeNotificationContextObj*) pContext);
0302		return true;
0303		}
0304	//--------------------------------------------------------------------------------
0305	bool CChangeNotificationSubSystem::AddWatch(HKEY hKey, CSystemObject* pTarget, int nMsgId, bool bWatchSubDir, DWORD nFilter)
0306		{
0307		CRegChangeNotificationContextObj* pContext = new CRegChangeNotificationContextObj;
0308		if(! pContext->Create(hKey, bWatchSubDir, nFilter, pTarget, nMsgId))
0309			{
0310			delete pContext;
0311			return false;
0312			}
0313		QueueContext((CChangeNotificationContextObj*) pContext);
0314		return true;
0315		}
0316	//--------------------------------------------------------------------------------
0317	int CChangeNotificationSubSystem::GetObjectId()
0318		{
0319		return OIDTM_SUBSYSTEM + SLOID_CN;
0320		}
0321	//--------------------------------------------------------------------------------
0322	bool CChangeNotificationSubSystem::PostNextThreadMessage(UINT, WPARAM, LPARAM)
0323		{
0324		return false;
0325		}
ZZHEYXXHEYFile: ChangeNotificationSubSystem.hYYHEY

0326	//--------------------------------------------------------------------------------
0327	// Copyright (c) 2001 @COMPANY
0328	// Created...: 6/11/01
0329	// Author....: Rich Schonthal
0330	//--------------------------------------------------------------------------------
0331	#if !defined(AFX_CHANGENOTIFICATIONSUBSYSTEM_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_)
0332	#define AFX_CHANGENOTIFICATIONSUBSYSTEM_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_
0333	#if _MSC_VER > 1000
0334	#pragma once
0335	#endif // _MSC_VER > 1000
0336	//--------------------------------------------------------------------------------
0337	#include "SubSystem.h"
0338	#include "System.h"
0339	#include "ChangeNotificationThread.h"
0340	#include "ChangeNotificationContextObj.h"
0341	#include <Directory.h>
0342	#include <StdobjQueue.h>
0343	#include <ContextSwitcher.h>
0344	#ifndef __AFXTEMPL_H__
0345	#include <afxtempl.h>
0346	#endif
0347	//--------------------------------------------------------------------------------
0348	class CChangeNotificationSubSystem : public CThreadPoolSubSystem, public CContextSwitcher<CChangeNotificationContextObj>
0349		{
0350		// needs to access AddToQueue and MsgAddToQueue
0351		friend class CChangeNotificationThread;
0352		public:
0353			DECLARE_DYNAMIC(CChangeNotificationSubSystem);
0354			enum
0355				{
0356				MsgChangeNotify = CSystem::MSG_DERIVED_START
0357				};
0358		public:
0359			CChangeNotificationSubSystem(CSystem*);
0360			virtual ~CChangeNotificationSubSystem();
0361			bool AddWatch(LPCTSTR pPath, CSystemObject* pTarget, int nMsgId = WM_USER,
0362				bool bWatchSubDir = true, DWORD nFilter = 0xffffffff);
0363			bool AddWatch(HKEY, CSystemObject* pTarget, int nMsgId = WM_USER,
0364				bool bWatchSubDir = true, DWORD nFilter = 0xffffffff);
0365			virtual int GetObjectId();
0366		protected:
0367			// cant do this with this sub system since each thread is watching a different directory
0368			virtual bool PostNextThreadMessage(UINT, WPARAM = 0, LPARAM = 0);
0369		};
0370	#endif // !defined(AFX_CHANGENOTIFICATIONSUBSYSTEM_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: ChangeNotificationThread.cppYYHEY

0371	//--------------------------------------------------------------------------------
0372	// Copyright (c) 2001 @COMPANY
0373	// Created...: 6/8/01
0374	// Author....: Rich Schonthal
0375	//--------------------------------------------------------------------------------
0376	#include "stdafx.h"
0377	#include "ChangeNotificationThread.h"
0378	#include "ChangeNotificationSubSystem.h"
0379	#ifdef _DEBUG
0380	#undef THIS_FILE
0381	static char THIS_FILE[]=__FILE__;
0382	#define new DEBUG_NEW
0383	#endif
0384	//--------------------------------------------------------------------------------
0385	IMPLEMENT_DYNCREATE(CChangeNotificationThread, CThreadObject);
0386	//--------------------------------------------------------------------------------
0387	CChangeNotificationThread::CChangeNotificationThread()
0388			: CTypedThreadObject<CSystem, CChangeNotificationSubSystem>(NULL)
0389		{
0390		}
0391	//--------------------------------------------------------------------------------
0392	CChangeNotificationThread::~CChangeNotificationThread()
0393		{
0394		}
0395	//--------------------------------------------------------------------------------
0396	DWORD CChangeNotificationThread::GetThreadLoopSleepInterval() const
0397		{
0398		return 100;
0399		}
0400	//--------------------------------------------------------------------------------
0401	bool CChangeNotificationThread::MainLoop()
0402		{
0403		CChangeNotificationContextObj* pContext = GetSubSystem()->GetNextContext();
0404		if(pContext == NULL)
0405			return true;
0406		if(! pContext->IsValid())
0407			{
0408			GetSubSystem()->QueueContext(pContext);
0409			return true;
0410			}
0411		if(::WaitForSingleObject(pContext->m_event, 0) == WAIT_OBJECT_0)
0412			{
0413			if(! pContext->IsChangeReady())
0414				{
0415				GetSubSystem()->QueueContext(pContext);
0416				return true;
0417				}
0418			if(! pContext->PostChanges())
0419				{
0420				GetSubSystem()->QueueContext(pContext);
0421				return true;
0422				}
0423			if(! pContext->GetNextChange())
0424				{
0425				GetSubSystem()->QueueContext(pContext);
0426				return true;
0427				}
0428			}
0429		GetSubSystem()->QueueContext(pContext);
0430		return true;
0431		}
0432	//--------------------------------------------------------------------------------
0433	int CChangeNotificationThread::GetObjectId()
0434		{
0435		return OIDTM_THREAD + SLOID_CN;
0436		}
ZZHEYXXHEYFile: ChangeNotificationThread.hYYHEY

0437	//--------------------------------------------------------------------------------
0438	// Copyright (c) 2001 @COMPANY
0439	// Created...: 6/8/01
0440	// Author....: Rich Schonthal
0441	//--------------------------------------------------------------------------------
0442	#if !defined(AFX_CHANGENOTIFICATIONTHREAD_H__1A4AB94F_5C82_11D5_B191_00A0CC271D0D__INCLUDED_)
0443	#define AFX_CHANGENOTIFICATIONTHREAD_H__1A4AB94F_5C82_11D5_B191_00A0CC271D0D__INCLUDED_
0444	#if _MSC_VER > 1000
0445	#pragma once
0446	#endif // _MSC_VER > 1000
0447	//--------------------------------------------------------------------------------
0448	#include <Directory.h>
0449	#include <Handle.h>
0450	#include <FileNotifyInformation.h>
0451	#include "ThreadObject.h"
0452	//--------------------------------------------------------------------------------
0453	class CChangeNotificationSubSystem;
0454	//--------------------------------------------------------------------------------
0455	class CChangeNotificationThread : public CTypedThreadObject<CSystem, CChangeNotificationSubSystem>
0456		{
0457		DECLARE_DYNCREATE(CChangeNotificationThread);
0458		public:
0459			CChangeNotificationThread();
0460			virtual ~CChangeNotificationThread();
0461			virtual bool MainLoop();
0462			virtual DWORD GetThreadLoopSleepInterval() const;
0463			int GetPathIndex() const;
0464			int GetObjectId();
0465		};
0466	#endif // !defined(AFX_CHANGENOTIFICATIONTHREAD_H__1A4AB94F_5C82_11D5_B191_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: DBDatabase.cppYYHEY

0467	//--------------------------------------------------------------------------------
0468	//
0469	// Copyright (c) 2000 @COMPANY
0470	//
0471	// Programming by Rich Schonthal
0472	//
0473	//--------------------------------------------------------------------------------
0474	#include "stdafx.h"
0475	#include "DBDatabase.h"
0476	#include <WriteLock.h>
0477	#include <ReadLock.h>
0478	//--------------------------------------------------------------------------------
0479	CDBDatabase::CDBDatabase()
0480			: m_pMap(new Map)
0481			, m_pList(new List)
0482		{
0483		}
0484	//--------------------------------------------------------------------------------
0485	CDBDatabase::~CDBDatabase()
0486		{
0487		delete m_pMap;
0488		delete m_pList;
0489		}
0490	//--------------------------------------------------------------------------------
0491	bool CDBDatabase::Add(CDBDatabaseElement* pObj)
0492		{
0493		CWriteLock lock(this, false);
0494		if(! lock.Lock(10000))
0495			return false;
0496		if(m_pList->AddTail(pObj) == NULL)
0497			return false;
0498		m_pMap->SetAt(pObj->m_nElementId, pObj);
0499		return true;
0500		}
0501	// returns the number of items removed
0502	//--------------------------------------------------------------------------------
0503	int CDBDatabase::Remove(CDBDatabaseElement* pObj, bool bDelete)
0504		{
0505		CWriteLock lock(this, false);
0506		if(! lock.Lock(10000))
0507			return 0;
0508		int nCount = 0;
0509		for(POSITION pos;;)
0510			{
0511			pos = m_pList->Find(pObj);
0512			if(pos == NULL)
0513				break;
0514			m_pList->RemoveAt(pos);
0515			nCount++;
0516			}
0517		m_pMap->RemoveKey(pObj->m_nElementId);
0518		if(bDelete)
0519			delete pObj;
0520		return nCount;
0521		}
0522	//--------------------------------------------------------------------------------
0523	bool CDBDatabase::ReQueue(CDBDatabaseElement* pObj)
0524		{
0525		CWriteLock lock(this, false);
0526		if(! lock.Lock(10000))
0527			return false;
0528		POSITION pos = m_pList->Find(pObj);
0529		if(pos != NULL)
0530			m_pList->RemoveAt(pos);
0531		return m_pList->AddTail(pObj) != NULL;
0532		}
0533	//--------------------------------------------------------------------------------
0534	bool CDBDatabase::Move(CDBDatabaseElement* pObj, CDBDatabase* pDB)
0535		{
0536		CWriteLock lock1(this);
0537		if(! lock1.Lock(10000))
0538			return false;
0539		CWriteLock lock2(this);
0540		if(! lock2.Lock(10000))
0541			return false;
0542		Remove(pObj);
0543		// an error?
0544		if(pDB->m_pList->AddTail(pObj) == NULL)
0545			return false;
0546		// insert into the new map
0547		pDB->m_pMap->SetAt(pObj->m_nElementId, pObj);
0548		return true;
0549		}
0550	//--------------------------------------------------------------------------------
0551	POSITION CDBDatabase::GetHeadPosition()
0552		{
0553		CReadLock lock(this, false);
0554		if(! lock.Lock(10000))
0555			return NULL;
0556		return m_pList->GetHeadPosition();
0557		}
0558	//--------------------------------------------------------------------------------
0559	CDBDatabaseElement* CDBDatabase::GetNext(POSITION& pos)
0560		{
0561		CReadLock lock(this, false);
0562		if(! lock.Lock(10000))
0563			return NULL;
0564		return m_pList->GetNext(pos);
0565		}
0566	//--------------------------------------------------------------------------------
0567	CDBDatabaseElement* CDBDatabase::GetNextAndReQueue()
0568		{
0569		CWriteLock lock(this, false);
0570		if(! lock.Lock(10000))
0571			return false;
0572		CDBDatabaseElement* pElement = NULL;
0573		POSITION pos = m_pList->GetHeadPosition();
0574		if(pos == NULL)
0575			return NULL;
0576		pElement = m_pList->GetAt(pos);
0577		m_pList->RemoveAt(pos);
0578		m_pList->AddTail(pElement);
0579		return pElement;
0580		}
0581	//--------------------------------------------------------------------------------
0582	CDBDatabaseElement* CDBDatabase::Find(DWORD nId)
0583		{
0584		CReadLock lock(this, false);
0585		if(! lock.Lock(10000))
0586			return false;
0587		CDBDatabaseElement* pElement = NULL;
0588		if(! m_pMap->Lookup(nId, pElement))
0589			return NULL;
0590		return pElement;
0591		}
0592	//--------------------------------------------------------------------------------
0593	int CDBDatabase::GetCount()
0594		{
0595		CReadLock lock(this, false);
0596		if(! lock.Lock(10000))
0597			return false;
0598		return m_pMap->GetCount();
0599		}
ZZHEYXXHEYFile: DBDatabase.hYYHEY

0600	//--------------------------------------------------------------------------------
0601	//
0602	// Copyright (c) 2000 @COMPANY
0603	//
0604	// Programming by Rich Schonthal
0605	//
0606	//--------------------------------------------------------------------------------
0607	#ifndef _DBDATABASE_H_
0608	#define _DBDATABASE_H_
0609	//--------------------------------------------------------------------------------
0610	#include <ReadWriteObject.h>
0611	//--------------------------------------------------------------------------------
0612	class CDBDatabaseElement
0613		{
0614		friend class CDBDatabase;
0615		protected:
0616			DWORD m_nElementId;
0617		public:
0618			CDBDatabaseElement()
0619				: m_nElementId(0)
0620				{
0621				};
0622			virtual ~CDBDatabaseElement() {}
0623		};
0624	//--------------------------------------------------------------------------------
0625	class CDBDatabase : public CReadWriteObject
0626		{
0627		public:
0628			class Map : public CMap<DWORD, DWORD, CDBDatabaseElement*, CDBDatabaseElement*&>
0629				{
0630				};
0631			class List : public CTypedPtrList<CPtrList, CDBDatabaseElement*>
0632				{
0633				};
0634		public:
0635			Map* m_pMap;
0636			List* m_pList;
0637		public:
0638			CDBDatabase();
0639			virtual ~CDBDatabase();
0640		public:
0641			// adds a the element to the list and the end of the queue
0642			bool Add(CDBDatabaseElement*);
0643			// remove element from list and queue
0644			int Remove(CDBDatabaseElement*, bool bDelete = false);
0645			// move element to the end of the queue and update
0646			// the position data memeber
0647			bool ReQueue(CDBDatabaseElement*);
0648			// move an element from this database to pDB
0649			bool Move(CDBDatabaseElement*, CDBDatabase* pDB);
0650			// gets the position of the head element
0651			POSITION GetHeadPosition();
0652			// gets the element at position pos, and advances pos to the next position - null at end
0653			CDBDatabaseElement* GetNext(POSITION& pos);
0654			// gets the element from the top of the queue, moves it to the end of the queue
0655			CDBDatabaseElement* GetNextAndReQueue();
0656			// locates an element by id
0657			CDBDatabaseElement* Find(DWORD);
0658			// returns the number of records in the database
0659			int GetCount();
0660		};
0661	#endif //_DBDATABASE_H_
ZZHEYXXHEYFile: DBSubSystem.cppYYHEY

0662	//--------------------------------------------------------------------------------
0663	//
0664	// Copyright (c) 1999 @COMPANY
0665	//
0666	// Programming by Rich Schonthal
0667	//
0668	//--------------------------------------------------------------------------------
0669	//--------------------------------------------------------------------------------
0670	#include "stdafx.h"
0671	#include "DBSubSystem.h"
0672	#include "DBDatabase.h"
0673	//--------------------------------------------------------------------------------
0674	CDBSubSystem::CDBSubSystem(CSystem* pParent)
0675			: CSubSystem(pParent)
0676		{
0677		}
0678	//--------------------------------------------------------------------------------
0679	CDBSubSystem::~CDBSubSystem()
0680		{
0681		}
0682	//--------------------------------------------------------------------------------
0683	int CDBSubSystem::GetObjectId()
0684		{
0685		return OIDM_SUBSYSTEM + SLOID_DB;
0686		}
ZZHEYXXHEYFile: DBSubSystem.hYYHEY

0687	//--------------------------------------------------------------------------------
0688	//
0689	// Copyright (c) 1999 @COMPANY
0690	//
0691	// Programming by Rich Schonthal
0692	//
0693	//--------------------------------------------------------------------------------
0694	#if !defined(AFX_DBSUBSYSTEM_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_)
0695	#define AFX_DBSUBSYSTEM_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_
0696	#if _MSC_VER > 1000
0697	#pragma once
0698	#endif // _MSC_VER > 1000
0699	//--------------------------------------------------------------------------------
0700	#include <SubSystem.h>
0701	//--------------------------------------------------------------------------------
0702	class CDBSubSystem : public CSubSystem
0703		{
0704		public:
0705			CDBSubSystem(CSystem*);
0706			virtual ~CDBSubSystem();
0707			virtual int GetObjectId();
0708		};
0709	#endif // !defined(AFX_DBSUBSYSTEM_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: FileChangeNotificationContextObj.cppYYHEY

0710	//--------------------------------------------------------------------------------
0711	// Copyright (c) 2001 @COMPANY
0712	// Created...: 6/8/01
0713	// Author....: Rich Schonthal
0714	//--------------------------------------------------------------------------------
0715	#include "stdafx.h"
0716	#include "ChangeNotificationContextObj.h"
0717	#include "ChangeNotificationObj.h"
0718	#include <SystemObject.h>
0719	#include <Directory.h>
0720	#include <AllocString.h>
0721	#ifdef _DEBUG
0722	#undef THIS_FILE
0723	static char THIS_FILE[]=__FILE__;
0724	#define new DEBUG_NEW
0725	#endif
0726	//--------------------------------------------------------------------------------
0727	CFileChangeNotificationContextObj::CFileChangeNotificationContextObj()
0728			: m_pPath(NULL)
0729			, m_hCompletionPort(INVALID_HANDLE_VALUE)
0730			, m_nCurBufIndex(0)
0731			, m_pPrevRenameObj(NULL)
0732		{
0733		}
0734	//--------------------------------------------------------------------------------
0735	bool CFileChangeNotificationContextObj::Create(LPCTSTR pPath, bool bWatchSubDir, DWORD nFilter, CSystemObject* pTarget, int nMsgId)
0736		{
0737		if(m_pReadDirectoryChangesW == NULL)
0738			return false;
0739		CDirectory::CreatePath(pPath);
0740		m_hDir = ::CreateFile(pPath,
0741			  FILE_LIST_DIRECTORY,                // access (read-write) mode
0742			  FILE_SHARE_READ|FILE_SHARE_WRITE,//|FILE_SHARE_DELETE,  // share mode
0743			  NULL,                               // security descriptor
0744			  OPEN_EXISTING,                      // how to create
0745			  FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED ,         // file attributes
0746			  NULL                                // file with attributes to copy
0747			  );
0748		if(! m_hDir.IsValid())
0749			return false;
0750		m_pPath = pPath;
0751		m_bWatchSubDir = bWatchSubDir;
0752		if(nFilter == 0xffffffff)
0753			nFilter = FILE_NOTIFY_CHANGE_FILE_NAME|FILE_NOTIFY_CHANGE_DIR_NAME|FILE_NOTIFY_CHANGE_ATTRIBUTES|
0754				FILE_NOTIFY_CHANGE_SIZE|FILE_NOTIFY_CHANGE_LAST_WRITE|FILE_NOTIFY_CHANGE_LAST_ACCESS|
0755				FILE_NOTIFY_CHANGE_CREATION|FILE_NOTIFY_CHANGE_SECURITY;
0756		m_nFilter = nFilter;
0757		m_pTarget = pTarget;
0758		m_nMessageId = nMsgId;
0759		memset(&m_overlapped, 0, sizeof(m_overlapped));
0760		m_overlapped.hEvent = m_event;
0761		m_event.ResetEvent();
0762		m_hCompletionPort = ::CreateIoCompletionPort(m_hDir, NULL, (DWORD) m_pBuffer, 0);
0763		DWORD nSize;
0764		nSize = GetLastError();
0765		(m_pReadDirectoryChangesW)(m_hDir, m_pBuffer, BUFFER_SIZE, m_bWatchSubDir, m_nFilter, &nSize, &m_overlapped, NULL);
0766		nSize = GetLastError();
0767		return true;
0768		}
0769	//--------------------------------------------------------------------------------
0770	CFileChangeNotificationContextObj::~CFileChangeNotificationContextObj()
0771		{
0772		delete m_pPrevRenameObj;
0773		}
0774	//--------------------------------------------------------------------------------
0775	LPCTSTR CFileChangeNotificationContextObj::GetPath() const
0776		{
0777		return m_pPath;
0778		}
0779	//--------------------------------------------------------------------------------
0780	bool CFileChangeNotificationContextObj::IsValid()
0781		{
0782		return m_hCompletionPort.IsValid();
0783		}
0784	//--------------------------------------------------------------------------------
0785	bool CFileChangeNotificationContextObj::IsChangeReady()
0786		{
0787		return ::GetQueuedCompletionStatus(m_hCompletionPort, &m_nSize, (DWORD*) &m_pBase, &m_pOverlap, 100) != 0;
0788		}
0789	//--------------------------------------------------------------------------------
0790	bool CFileChangeNotificationContextObj::PostChanges()
0791		{
0792		DWORD nOffset = 0;
0793		for(;;)
0794			{
0795			FILE_NOTIFY_INFORMATION* pOrigInfo = (FILE_NOTIFY_INFORMATION*) (m_pBase + nOffset);
0796			CFileChangeNotificationObj* pInfo = new CFileChangeNotificationObj(pOrigInfo, GetPath());
0797			nOffset += pOrigInfo->NextEntryOffset;
0798			if(pInfo->m_nAction == FILE_ACTION_RENAMED_OLD_NAME)
0799				{
0800				delete m_pPrevRenameObj;
0801				m_pPrevRenameObj = pInfo;
0802				}
0803			else
0804				{
0805				if(pInfo->m_nAction == FILE_ACTION_RENAMED_NEW_NAME)
0806					{
0807					if(m_pPrevRenameObj == NULL)
0808						{
0809						delete pInfo;
0810						return false;
0811						}
0812					pInfo->m_pOldFilename = AllocString(m_pPrevRenameObj->m_pFilename);
0813					delete m_pPrevRenameObj;
0814					m_pPrevRenameObj = NULL;
0815					}
0816				m_pTarget->PostMessage(GetMessageId(), (WPARAM) pInfo);
0817				}
0818			if(pOrigInfo->NextEntryOffset == 0)
0819				return true;
0820			}
0821		}
0822	//--------------------------------------------------------------------------------
0823	bool CFileChangeNotificationContextObj::GetNextChange()
0824		{
0825		m_event.ResetEvent();
0826		(m_pReadDirectoryChangesW)(m_hDir, m_pBuffer, BUFFER_BLOCK_SIZE, m_bWatchSubDir, m_nFilter, &m_nSize, &m_overlapped, NULL);
0827		return true;
0828		}
ZZHEYXXHEYFile: FileIndexDirObject.cppYYHEY

0829	//--------------------------------------------------------------------------------
0830	// Copyright (c) 2001 @COMPANY
0831	// Created...: 6/11/01
0832	// Author....: Rich Schonthal
0833	//--------------------------------------------------------------------------------
0834	#include "stdafx.h"
0835	#include "FileIndexDirObject.h"
0836	//--------------------------------------------------------------------------------
0837	static BOOL AFXAPI CompareElements<LPCTSTR, LPCTSTR>(LPCTSTR* pElement1, LPCTSTR* pElement2)
0838		{
0839		return stricmp(*pElement1, *pElement2) == 0;
0840		}
0841	// turn off the warning about using 'this' in the init list
0842	#pragma warning(disable : 4355)
0843	//--------------------------------------------------------------------------------
0844	CFileIndexDirObject::CFileIndexDirObject(LPCTSTR pDir)
0845			: CFileIndexObject(pDir)
0846			, m_files(this)
0847		{
0848		}
0849	#pragma warning(default : 4355)
0850	//--------------------------------------------------------------------------------
0851	UINT CFileIndexDirObject::GetObjectId()
0852		{
0853		return 1;
0854		}
0855	//--------------------------------------------------------------------------------
0856	bool CFileIndexDirObject::AddFile(CFileIndexFileObject* pFile)
0857		{
0858		CSingleLock lock(&m_mutex, false);
0859		if(! lock.Lock(1000))
0860			return false;
0861		CFileIndexFileObject* pTempFile;
0862		if(! m_files.Lookup(pFile->GetName(), (CFileIndexObject*&) pTempFile))
0863			m_files.SetAt(pFile->GetName(), pFile);
0864		return true;
0865		}
0866	//--------------------------------------------------------------------------------
0867	bool CFileIndexDirObject::FindFile(LPCTSTR pFilename, CFileIndexFileObject*& pFile)
0868		{
0869		CSingleLock lock(&m_mutex, false);
0870		if(! lock.Lock(1000))
0871			return false;
0872		return m_files.Lookup(pFilename, (CFileIndexObject*&) pFile) != 0;
0873		}
0874	//--------------------------------------------------------------------------------
0875	bool CFileIndexDirObject::RemoveFile(LPCTSTR pFilename)
0876		{
0877		CSingleLock lock(&m_mutex, false);
0878		if(! lock.Lock(1000))
0879			return false;
0880		CFileIndexFileObject* pFile;
0881		if(! m_files.Lookup(pFilename, (CFileIndexObject*&) pFile))
0882			return false;
0883		m_files.RemoveKey(pFilename);
0884		return true;
0885		}
0886	//--------------------------------------------------------------------------------
0887	bool CFileIndexDirObject::RemoveFile(CFileIndexFileObject* pWhich)
0888		{
0889		CSingleLock lock(&m_mutex, false);
0890		if(! lock.Lock(1000))
0891			return false;
0892		CFileIndexFileObject* pFile;
0893		if(! m_files.Lookup(pWhich->GetName(), (CFileIndexObject*&) pFile))
0894			return false;
0895		m_files.RemoveKey(pWhich->GetName());
0896		return true;
0897		}
0898	//--------------------------------------------------------------------------------
0899	bool CFileIndexDirObject::Write(CFile& file, bool bResetPosOnError)
0900		{
0901		if(CFileIndexObject::Write(file, bResetPosOnError))
0902			return m_files.Write(file);
0903		return false;
0904		}
0905	//--------------------------------------------------------------------------------
0906	bool CFileIndexDirObject::Read(CFile& file, bool bResetPosOnError)
0907		{
0908		if(CFileIndexObject::Read(file, bResetPosOnError))
0909			return m_files.Read(file);
0910		return false;
0911		}
0912	#ifdef _DEBUG
0913	//--------------------------------------------------------------------------------
0914	void CFileIndexDirObject::Dump(CStdioFile& dumpFile)
0915		{
0916		POSITION pos = m_files.GetStartPosition();
0917		LPCTSTR pKey;
0918		CFileIndexFileObject* pFile;
0919		CString sTemp;
0920		while(pos != NULL)
0921			{
0922			m_files.GetNextAssoc(pos, pKey, (CFileIndexObject*&) pFile);
0923			sTemp.Format("FILE: %s\\%s\n", GetName(), pFile->GetName());
0924			dumpFile.WriteString(sTemp);
0925			}
0926		}
0927	#endif
0928	//--------------------------------------------------------------------------------
0929	//--------------------------------------------------------------------------------
0930	//--------------------------------------------------------------------------------
0931	CFileIndexDirObjectMap::CFileIndexDirObjectMap()
0932		{
0933		m_nHashTableSize = 409;
0934		}
0935	//--------------------------------------------------------------------------------
0936	CFileIndexObject* CFileIndexDirObjectMap::CreateNewIndexObject(LPCTSTR pName)
0937		{
0938		return (CFileIndexObject*) new CFileIndexDirObject(pName);
0939		}
ZZHEYXXHEYFile: FileIndexDirObject.hYYHEY

0940	//--------------------------------------------------------------------------------
0941	// Copyright (c) 2001 @COMPANY
0942	// Created...: 6/11/01
0943	// Author....: Rich Schonthal
0944	//--------------------------------------------------------------------------------
0945	#if !defined(AFX_FILEINDEXDIROBJECT_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_)
0946	#define AFX_FILEINDEXDIROBJECT_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_
0947	#if _MSC_VER > 1000
0948	#pragma once
0949	#endif // _MSC_VER > 1000
0950	//--------------------------------------------------------------------------------
0951	#include "FileIndexObject.h"
0952	#include "FileIndexFileObject.h"
0953	#include <ReadWriteObject.h>
0954	#ifndef __AFXTEMPL_H__
0955	#include <afxtempl.h>
0956	#endif
0957	//--------------------------------------------------------------------------------
0958	class CFileIndexDirObject : public CFileIndexObject
0959		{
0960		protected:
0961			CFileIndexFileMap m_files;
0962		public:
0963			CFileIndexDirObject(LPCTSTR pDir);
0964			bool AddFile(CFileIndexFileObject*);
0965			bool FindFile(LPCTSTR pPath, CFileIndexFileObject*&);
0966			bool RemoveFile(LPCTSTR pFilename);
0967			bool RemoveFile(CFileIndexFileObject*);
0968			virtual UINT GetObjectId();
0969			virtual bool Write(CFile&, bool bResetPosOnError = true);
0970			virtual bool Read(CFile&, bool bResetPosOnError = true);
0971	#ifdef _DEBUG
0972			void Dump(CStdioFile&);
0973	#endif
0974		};
0975	//--------------------------------------------------------------------------------
0976	class CFileIndexDirObjectMap :	public CFileIndexObjMap
0977		{
0978		public:
0979			CFileIndexDirObjectMap();
0980			virtual CFileIndexObject* CreateNewIndexObject(LPCTSTR pName = NULL);
0981		};
0982	#endif // !defined(AFX_FILEINDEXDIROBJECT_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: FileIndexFileObject.cppYYHEY

0983	//--------------------------------------------------------------------------------
0984	// Copyright (c) 2001 @COMPANY
0985	// Created...: 6/11/01
0986	// Author....: Rich Schonthal
0987	//--------------------------------------------------------------------------------
0988	#include "stdafx.h"
0989	#include "FileIndexFileObject.h"
0990	//--------------------------------------------------------------------------------
0991	CFileIndexFileObject::CFileIndexFileObject(CFileIndexDirObject* pDir, LPCTSTR pFilename)
0992			: CFileIndexObject(pFilename)
0993			, m_pDir(pDir)
0994		{
0995		}
0996	//--------------------------------------------------------------------------------
0997	CFileIndexFileObject::~CFileIndexFileObject()
0998		{
0999		}
1000	//--------------------------------------------------------------------------------
1001	CFileIndexDirObject* CFileIndexFileObject::GetDir()
1002		{
1003		return m_pDir;
1004		}
1005	//--------------------------------------------------------------------------------
1006	UINT CFileIndexFileObject::GetObjectId()
1007		{
1008		return 2;
1009		}
1010	//--------------------------------------------------------------------------------
1011	//--------------------------------------------------------------------------------
1012	//--------------------------------------------------------------------------------
1013	CFileIndexFileMap::CFileIndexFileMap(CFileIndexDirObject* pOwnerObj)
1014			: m_pDirObj(pOwnerObj)
1015		{
1016		m_nHashTableSize = 2617;
1017		}
1018	//--------------------------------------------------------------------------------
1019	CFileIndexObject* CFileIndexFileMap::CreateNewIndexObject(LPCTSTR pName)
1020		{
1021		return (CFileIndexObject*) new CFileIndexFileObject(m_pDirObj, pName);
1022		}
ZZHEYXXHEYFile: FileIndexFileObject.hYYHEY

1023	//--------------------------------------------------------------------------------
1024	// Copyright (c) 2001 @COMPANY
1025	// Created...: 6/11/01
1026	// Author....: Rich Schonthal
1027	//--------------------------------------------------------------------------------
1028	#if !defined(AFX_FILEINDEXFILEOBJECT_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_)
1029	#define AFX_FILEINDEXFILEOBJECT_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_
1030	//--------------------------------------------------------------------------------
1031	#include "FileIndexObject.h"
1032	#include <ReadWriteObject.h>
1033	#ifndef __AFXTEMPL_H__
1034	#include <afxtempl.h>
1035	#endif
1036	//--------------------------------------------------------------------------------
1037	class CFileIndexDirObject;
1038	//--------------------------------------------------------------------------------
1039	class CFileIndexFileObject : public CFileIndexObject
1040		{
1041		protected:
1042			CFileIndexDirObject* m_pDir;
1043		public:
1044			CFileIndexFileObject(LPCTSTR pName = NULL);
1045			CFileIndexFileObject(CFileIndexDirObject* pDir, LPCTSTR pFilename);
1046			virtual ~CFileIndexFileObject();
1047			CFileIndexDirObject* GetDir();
1048			virtual UINT GetObjectId();
1049		};
1050	//--------------------------------------------------------------------------------
1051	class CFileIndexFileMap : public CFileIndexObjMap
1052		{
1053		protected:
1054			CFileIndexDirObject* m_pDirObj;
1055		public:
1056			CFileIndexFileMap(CFileIndexDirObject*);
1057			virtual CFileIndexObject* CreateNewIndexObject(LPCTSTR pName = NULL);
1058		};
1059	#endif//AFX_FILEINDEXFILEOBJECT_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_
ZZHEYXXHEYFile: FileIndexObject.cppYYHEY

1060	//--------------------------------------------------------------------------------
1061	// Copyright (c) 2001 @COMPANY
1062	// Created...: 6/11/01
1063	// Author....: Rich Schonthal
1064	//--------------------------------------------------------------------------------
1065	#include "stdafx.h"
1066	#include "FileIndexObject.h"
1067	//--------------------------------------------------------------------------------
1068	CFileIndexObject::CFileIndexObject(LPCTSTR pName)
1069			: m_sName(pName)
1070			, m_nRefCount(0)
1071		{
1072		}
1073	//--------------------------------------------------------------------------------
1074	CFileIndexObject::~CFileIndexObject()
1075		{
1076		}
1077	//--------------------------------------------------------------------------------
1078	LPCTSTR CFileIndexObject::GetName()
1079		{
1080		return m_sName;
1081		}
1082	//--------------------------------------------------------------------------------
1083	void CFileIndexObject::SetName(LPCTSTR pName)
1084		{
1085		m_sName = pName;
1086		}
1087	//--------------------------------------------------------------------------------
1088	UINT CFileIndexObject::GetObjectId()
1089		{
1090		return 0;
1091		}
1092	//--------------------------------------------------------------------------------
1093	bool CFileIndexObject::Write(CFile& file, bool bResetPosOnError)
1094		{
1095		ULONGLONG nPos;
1096		bool bPosOk = false;
1097		bool bRv = true;
1098		TRY
1099			{
1100			if(bResetPosOnError)
1101				{
1102				nPos = file.GetPosition();
1103				bPosOk = true;
1104				}
1105			DWORD nNum = GetObjectId();
1106			file.Write(&nNum, sizeof(nNum));
1107			nNum = m_sName.GetLength();
1108			file.Write(&nNum, sizeof(nNum));
1109			file.Write((LPCTSTR) m_sName, nNum);
1110		char temp[1024];
1111		file.Write(temp, 1024);
1112			}
1113		CATCH_ALL(e)
1114			{
1115			bRv = false;
1116			}
1117		END_CATCH_ALL;
1118		if(bPosOk && bResetPosOnError && ! bRv)
1119			TRY
1120				{
1121				file.Seek(nPos, CFile::begin);
1122				}
1123			CATCH_ALL(e)
1124				{
1125				}
1126			END_CATCH_ALL;
1127		return bRv;
1128		}
1129	//--------------------------------------------------------------------------------
1130	bool CFileIndexObject::Read(CFile& file, bool bResetPosOnError)
1131		{
1132		ULONGLONG nPos;
1133		bool bPosOk = false;
1134		DWORD nNum;
1135		char* pBuf = NULL;
1136		bool bRv = true;
1137		TRY
1138			{
1139			if(bResetPosOnError)
1140				{
1141				nPos = file.GetPosition();
1142				bPosOk = true;
1143				}
1144			// read the object id
1145			if(file.Read(&nNum, sizeof(nNum)) == sizeof(nNum))
1146				// be sure we're reading the object we want
1147				if(nNum == GetObjectId())
1148					// read the name length
1149					if(file.Read(&nNum, sizeof(nNum)) == sizeof(nNum))
1150						{
1151						pBuf = m_sName.GetBuffer(nNum);
1152						bRv = (file.Read(pBuf, nNum) == nNum);
1153						}
1154		char temp[1024];
1155		file.Read(temp, 1024);
1156			}
1157		CATCH_ALL(e)
1158			{
1159			bRv = false;
1160			}
1161		END_CATCH_ALL;
1162		if(pBuf != NULL)
1163			m_sName.ReleaseBuffer();
1164		if(bResetPosOnError && bPosOk && ! bRv)
1165			TRY
1166				{
1167				file.Seek(nPos, CFile::begin);
1168				}
1169			CATCH_ALL(e)
1170				{
1171				}
1172			END_CATCH_ALL;
1173		return bRv;
1174		}
1175	//--------------------------------------------------------------------------------
1176	//--------------------------------------------------------------------------------
1177	//--------------------------------------------------------------------------------
1178	CFileIndexObjMap::CFileIndexObjMap()
1179		{
1180		m_nHashTableSize = 257;
1181		}
1182	//--------------------------------------------------------------------------------
1183	bool CFileIndexObjMap::Write(CFile& file)
1184		{
1185		ULONGLONG nPos;
1186		bool bPosOk = false;
1187		bool bRv = true;
1188		POSITION pos = GetStartPosition();
1189		TRY
1190			{
1191			nPos = file.GetPosition();
1192			bPosOk = true;
1193			DWORD nNum = 'CMAP';
1194			file.Write(&nNum, sizeof(nNum));
1195			nNum = GetCount();
1196			file.Write(&nNum, sizeof(nNum));
1197			}
1198		CATCH_ALL(e)
1199			{
1200			bRv = false;
1201			pos = NULL;
1202			}
1203		END_CATCH_ALL;
1204		while(pos != NULL)
1205			TRY
1206				{
1207				LPCTSTR pKey;
1208				CFileIndexObject* pObj;
1209				GetNextAssoc(pos, pKey, pObj);
1210				if(pObj == NULL)
1211					THROW(new CFileIndexObjException);
1212				pObj->Write(file, false);
1213				}
1214			CATCH_ALL(e)
1215				{
1216				bRv = false;
1217				break;
1218				}
1219			END_CATCH_ALL;
1220		if(bPosOk && ! bRv)
1221			TRY
1222				{
1223				file.Seek(nPos, CFile::begin);
1224				}
1225			CATCH_ALL(e)
1226				{
1227				}
1228			END_CATCH_ALL;
1229		return bRv;
1230		}
1231	//--------------------------------------------------------------------------------
1232	bool CFileIndexObjMap::Read(CFile& file)
1233		{
1234		ULONGLONG nPos;
1235		bool bPosOk = false;
1236		bool bRv = true;
1237		POSITION pos = GetStartPosition();
1238		int nCount;
1239		TRY
1240			{
1241			nPos = file.GetPosition();
1242			bPosOk = true;
1243			DWORD nNum;
1244			if(file.Read(&nNum, sizeof(nNum)) != sizeof(nNum) || nNum != 'CMAP')
1245				bRv = false;
1246			if(file.Read(&nNum, sizeof(nNum)) != sizeof(nNum))
1247				bRv = false;
1248			nCount = nNum;
1249			}
1250		CATCH_ALL(e)
1251			{
1252			bRv = false;
1253			}
1254		END_CATCH_ALL;
1255		for(int i = 0; i < nCount; i++)
1256			{
1257			CFileIndexObject* pObj = CreateNewIndexObject();
1258			bRv = pObj->Read(file, false);
1259			if(! bRv)
1260				{
1261				delete pObj;
1262				break;
1263				}
1264			SetAt(pObj->GetName(), pObj);
1265			}
1266		if(bPosOk && ! bRv)
1267			TRY
1268				{
1269				file.Seek(nPos, CFile::begin);
1270				}
1271			CATCH_ALL(e)
1272				{
1273				}
1274			END_CATCH_ALL;
1275		return bRv;
1276		}
1277	//--------------------------------------------------------------------------------
1278	CFileIndexObject* CFileIndexObjMap::CreateNewIndexObject(LPCTSTR pName)
1279		{
1280		return new CFileIndexObject(pName);
1281		}
ZZHEYXXHEYFile: FileIndexObject.hYYHEY

1282	//--------------------------------------------------------------------------------
1283	// Copyright (c) 2001 @COMPANY
1284	// Created...: 6/11/01
1285	// Author....: Rich Schonthal
1286	//--------------------------------------------------------------------------------
1287	#if !defined(AFX_FILEINDEXOBJECT_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_)
1288	#define AFX_FILEINDEXOBJECT_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_
1289	//--------------------------------------------------------------------------------
1290	#include <ReadWriteObject.h>
1291	#ifndef __AFXTEMPL_H__
1292	#include <afxtempl.h>
1293	#endif
1294	//--------------------------------------------------------------------------------
1295	class CFileIndexObject
1296		{
1297		public:
1298			CMutex m_mutex;
1299			LONG m_nRefCount;
1300		protected:
1301			CString m_sName;
1302		public:
1303			CFileIndexObject(LPCTSTR pName);
1304			virtual ~CFileIndexObject();
1305			LPCTSTR GetName();
1306			void SetName(LPCTSTR pName);
1307			virtual UINT GetObjectId();
1308			virtual bool Write(CFile&, bool bResetPosOnError = true);
1309			virtual bool Read(CFile&, bool bResetPosOnError = true);
1310		};
1311	//--------------------------------------------------------------------------------
1312	class CFileIndexObjMap : public CReadWriteObject, public CMap<LPCTSTR, LPCTSTR, CFileIndexObject*, CFileIndexObject*>
1313		{
1314		public:
1315			CFileIndexObjMap();
1316			virtual bool Write(CFile&);
1317			virtual bool Read(CFile&);
1318			virtual CFileIndexObject* CreateNewIndexObject(LPCTSTR pName = NULL);
1319		};
1320	//--------------------------------------------------------------------------------
1321	class CFileIndexObjException : public CException
1322		{
1323		};
1324	#endif//AFX_FILEINDEXOBJECT_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_
ZZHEYXXHEYFile: FileIndexSubSystem.cppYYHEY

1325	//--------------------------------------------------------------------------------
1326	// Copyright (c) 2001 @COMPANY
1327	// Created...: 6/11/01
1328	// Author....: Rich Schonthal
1329	//--------------------------------------------------------------------------------
1330	#include "stdafx.h"
1331	#include "FileIndexSubSystem.h"
1332	#include <ReadLock.h>
1333	#include <WriteLock.h>
1334	#include <Handle.h>
1335	//--------------------------------------------------------------------------------
1336	IMPLEMENT_DYNAMIC(CFileIndexSubSystem, CChangeNotificationSubSystem);
1337	//--------------------------------------------------------------------------------
1338	BOOL AFXAPI CompareElements<LPCTSTR, LPCTSTR>(LPCTSTR* pElement1, LPCTSTR* pElement2)
1339		{
1340		return stricmp(*pElement1, *pElement2) == 0;
1341		}
1342	//--------------------------------------------------------------------------------
1343	CFileIndexSubSystem::CFileIndexSubSystem(CSystem* pParent)
1344			: CChangeNotificationSubSystem(pParent)
1345		{
1346		}
1347	//--------------------------------------------------------------------------------
1348	CFileIndexSubSystem::~CFileIndexSubSystem()
1349		{
1350		}
1351	//--------------------------------------------------------------------------------
1352	bool CFileIndexSubSystem::AddDirectory(LPCTSTR pDir, CFileIndexDirObject*& pObj)
1353		{
1354		pObj = NULL;
1355		CWriteLock lock(&m_tree, false);
1356		if(! lock.Lock(1000))
1357			return false;
1358		return AddDirectory(pDir, pObj, lock);
1359		}
1360	//--------------------------------------------------------------------------------
1361	bool CFileIndexSubSystem::AddDirectory(LPCTSTR pDir, CFileIndexDirObject*& pObj, CWriteLock& lock)
1362		{
1363		pObj = NULL;
1364		CFileIndexDirObject* pTemp;
1365		if(m_tree.Lookup(pDir, (CFileIndexObject*&) pTemp))
1366			return false;
1367		pObj = new CFileIndexDirObject(pDir);
1368		m_tree.SetAt(pObj->GetName(), pObj);
1369		return true;
1370		}
1371	//--------------------------------------------------------------------------------
1372	bool CFileIndexSubSystem::FindDirectory(LPCTSTR pPath, CFileIndexDirObject*& pObj)
1373		{
1374		CReadLock lock(&m_tree, false);
1375		if(! lock.Lock(1000))
1376			return false;
1377		return m_tree.Lookup(pPath, (CFileIndexObject*&) pObj) != 0;
1378		}
1379	//--------------------------------------------------------------------------------
1380	bool CFileIndexSubSystem::RemoveDirectory(LPCTSTR pPath)
1381		{
1382		CWriteLock lock(&m_tree, false);
1383		if(! lock.Lock(1000))
1384			return false;
1385		return m_tree.RemoveKey(pPath) != 0;
1386		}
1387	//--------------------------------------------------------------------------------
1388	bool CFileIndexSubSystem::RemoveDirectory(CFileIndexDirObject* pObj)
1389		{
1390		CWriteLock lock(&m_tree, false);
1391		if(! lock.Lock(1000))
1392			return false;
1393		return m_tree.RemoveKey(pObj->GetName()) != 0;
1394		}
1395	//--------------------------------------------------------------------------------
1396	bool CFileIndexSubSystem::AddFile(LPCTSTR pFullPathname, CFileIndexDirObject*& pDir, CFileIndexFileObject*& pFile)
1397		{
1398		if(pFullPathname == NULL || *pFullPathname == 0)
1399			return false;
1400		CString sPath;
1401		CString sFilename;
1402		if(! CDirectory::ParsePath(pFullPathname, sPath, sFilename))
1403			return false;
1404		return AddFile(sPath, sFilename, pDir, pFile);
1405		}
1406	//--------------------------------------------------------------------------------
1407	bool CFileIndexSubSystem::AddFile(LPCTSTR pFullPathname, CFileIndexDirObject*& pDir, CFileIndexFileObject*& pFile, CWriteLock& lock)
1408		{
1409		if(pFullPathname == NULL || *pFullPathname == 0)
1410			return false;
1411		CString sPath;
1412		CString sFilename;
1413		if(! CDirectory::ParsePath(pFullPathname, sPath, sFilename))
1414			return false;
1415		return AddFile(sPath, sFilename, pDir, pFile, lock);
1416		}
1417	//--------------------------------------------------------------------------------
1418	bool CFileIndexSubSystem::AddFile(LPCTSTR pDirname, LPCTSTR pFilename, CFileIndexDirObject*& pDir, CFileIndexFileObject*& pFile)
1419		{
1420		pDir = NULL;
1421		pFile = NULL;
1422		if(pDirname == NULL || *pDirname == 0 || pFilename == NULL || *pFilename == 0)
1423			return false;
1424		CWriteLock lock(&m_tree, false);
1425		if(! lock.Lock(1000))
1426			return false;
1427		return AddFile(pDirname, pFilename, pDir, pFile, lock);
1428		}
1429	//--------------------------------------------------------------------------------
1430	bool CFileIndexSubSystem::AddFile(LPCTSTR pDirname, LPCTSTR pFilename, CFileIndexDirObject*& pDir, CFileIndexFileObject*& pFile,
1431									  CWriteLock& lock)
1432		{
1433		pDir = NULL;
1434		pFile = NULL;
1435		if(pDirname == NULL || *pDirname == 0 || pFilename == NULL || *pFilename == 0)
1436			return false;
1437		bool bIsNewDir = false;
1438		bool bIsNewFile = false;
1439		bool bRv = false;
1440		if(! m_tree.Lookup(pDirname, (CFileIndexObject*&) pDir))
1441			{
1442			bIsNewDir = true;
1443			pDir = CreateFileIndexDirObject(pDirname);
1444			if(pDir == NULL)
1445				return false;
1446			m_tree.SetAt(pDir->GetName(), pDir);
1447			}
1448		for(; pDir != NULL; )
1449			{
1450			CSingleLock lockDir(&pDir->m_mutex, false);
1451			if(lockDir.Lock(1000))
1452				{
1453				if(! pDir->FindFile(pFilename, pFile))
1454					{
1455					pFile = CreateFileIndexFileObject(pDir, pFilename);
1456					if(pFile == NULL)
1457						break;
1458					bIsNewFile = true;
1459					if(! pDir->AddFile(pFile))
1460						break;
1461					}
1462				bRv = true;
1463				}
1464			break;
1465			}
1466		if(! bRv)
1467			{
1468			if(bIsNewDir)
1469				{
1470				if(m_tree.Lookup(pDir->GetName(), (CFileIndexObject*&) pDir))
1471					m_tree.RemoveKey(pDir->GetName());
1472				delete pDir;
1473				pDir = NULL;
1474				}
1475			if(bIsNewFile)
1476				{
1477				delete pFile;
1478				pFile = NULL;
1479				}
1480			}
1481		return bRv;
1482		}
1483	//--------------------------------------------------------------------------------
1484	bool CFileIndexSubSystem::FindFile(LPCTSTR pFullPathname, CFileIndexDirObject*& pDir, CFileIndexFileObject*& pFile)
1485		{
1486		if(pFullPathname == NULL || *pFullPathname == 0)
1487			return false;
1488		CString sPath;
1489		CString sFilename;
1490		if(! CDirectory::ParsePath(pFullPathname, sPath, sFilename))
1491			return false;
1492		return FindFile(sPath, sFilename, pDir, pFile);
1493		}
1494	//--------------------------------------------------------------------------------
1495	bool CFileIndexSubSystem::FindFile(LPCTSTR pFullPathname, CFileIndexDirObject*& pDir, CFileIndexFileObject*& pFile, CWriteLock& lock)
1496		{
1497		if(pFullPathname == NULL || *pFullPathname == 0)
1498			return false;
1499		CString sPath;
1500		CString sFilename;
1501		if(! CDirectory::ParsePath(pFullPathname, sPath, sFilename))
1502			return false;
1503		return FindFile(sPath, sFilename, pDir, pFile, lock);
1504		}
1505	//--------------------------------------------------------------------------------
1506	bool CFileIndexSubSystem::FindFile(LPCTSTR pDirname, LPCTSTR pFilename, CFileIndexDirObject*& pDir, CFileIndexFileObject*& pFile)
1507		{
1508		pDir = NULL;
1509		pFile = NULL;
1510		if(pDirname == NULL || *pDirname == 0 || pFilename == NULL || *pFilename == 0)
1511			return false;
1512		CWriteLock lock(&m_tree, false);
1513		if(! lock.Lock(1000))
1514			return false;
1515		return FindFile(pDirname, pFilename, pDir, pFile, lock);
1516		}
1517	//--------------------------------------------------------------------------------
1518	bool CFileIndexSubSystem::FindFile(LPCTSTR pDirname, LPCTSTR pFilename, CFileIndexDirObject*& pDir, CFileIndexFileObject*& pFile,
1519									   CWriteLock& lock)
1520		{
1521		pDir = NULL;
1522		pFile = NULL;
1523		if(pDirname == NULL || *pDirname == 0 || pFilename == NULL || *pFilename == 0)
1524			return false;
1525		if(! m_tree.Lookup(pDirname, (CFileIndexObject*&) pDir))
1526			return false;
1527		return pDir->FindFile(pFilename, pFile);
1528		}
1529	//--------------------------------------------------------------------------------
1530	bool CFileIndexSubSystem::ParseDirectory(CString sPath, CWriteLock& lock)
1531		{
1532		WIN32_FIND_DATA data;
1533		CFindFileHandle hand = ::FindFirstFile(sPath + "\\*.*", &data);
1534		if(! hand.IsValid())
1535			return false;
1536		CFileIndexDirObject* pDir;
1537		CFileIndexFileObject* pFile;
1538		for(;;)
1539			{
1540			if(data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
1541				{
1542				if(data.cFileName[0] != '.')
1543					ParseDirectory(sPath + '\\' + data.cFileName, lock);
1544				}
1545			else
1546				AddFile(sPath, data.cFileName, pDir, pFile, lock);
1547			if(! ::FindNextFile(hand, &data))
1548				break;
1549			}
1550		return true;
1551		}
1552	//--------------------------------------------------------------------------------
1553	bool CFileIndexSubSystem::ParseNewWatchPath(LPCTSTR pPath)
1554		{
1555		CWriteLock lock(&m_tree, false);
1556		if(! lock.Lock(10000))
1557			return false;
1558		ParseDirectory(pPath, lock);
1559		return true;
1560		}
1561	//--------------------------------------------------------------------------------
1562	bool CFileIndexSubSystem::WriteIndex(CFile& file)
1563		{
1564		CReadLock lock(&m_tree, false);
1565		if(! lock.Lock(10000))
1566			return false;
1567		return m_tree.Write(file);
1568		}
1569	//--------------------------------------------------------------------------------
1570	bool CFileIndexSubSystem::ReadIndex(CFile& file)
1571		{
1572		CWriteLock lock(&m_tree, false);
1573		if(! lock.Lock(10000))
1574			return false;
1575		return m_tree.Read(file);
1576		}
1577	//--------------------------------------------------------------------------------
1578	CFileIndexDirObject* CFileIndexSubSystem::CreateFileIndexDirObject(LPCTSTR pDir)
1579		{
1580		return new CFileIndexDirObject(pDir);
1581		}
1582	//--------------------------------------------------------------------------------
1583	CFileIndexFileObject* CFileIndexSubSystem::CreateFileIndexFileObject(CFileIndexDirObject* pDir, LPCTSTR pFilename)
1584		{
1585		return new CFileIndexFileObject(pDir, pFilename);
1586		}
1587	#ifdef _DEBUG
1588	//--------------------------------------------------------------------------------
1589	void CFileIndexSubSystem::Dump(LPCTSTR pDumpFilename)
1590		{
1591		CStdioFile dumpFile;
1592		dumpFile.Open(pDumpFilename, CFile::modeCreate|CFile::modeWrite|CFile::shareExclusive);
1593		POSITION pos = m_tree.GetStartPosition();
1594		LPCTSTR pKey;
1595		CFileIndexDirObject* pDir;
1596		CString sTemp;
1597		while(pos != NULL)
1598			{
1599			m_tree.GetNextAssoc(pos, pKey, (CFileIndexObject*&) pDir);
1600			sTemp.Format(" DIR: %s\n", pDir->GetName());
1601			dumpFile.WriteString(sTemp);
1602			pDir->Dump(dumpFile);
1603			}
1604		}
1605	#endif
ZZHEYXXHEYFile: FileIndexSubSystem.hYYHEY

1606	//--------------------------------------------------------------------------------
1607	// Copyright (c) 2001 @COMPANY
1608	// Created...: 6/11/01
1609	// Author....: Rich Schonthal
1610	//--------------------------------------------------------------------------------
1611	#if !defined(AFX_FILEINDEXSUBSYSTEM_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_)
1612	#define AFX_FILEINDEXSUBSYSTEM_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_
1613	#if _MSC_VER > 1000
1614	#pragma once
1615	#endif // _MSC_VER > 1000
1616	//--------------------------------------------------------------------------------
1617	#include "SubSystem.h"
1618	#include "System.h"
1619	#include "ChangeNotificationSubSystem.h"
1620	#include "FileIndexDirObject.h"
1621	#include <Directory.h>
1622	#include <WriteLock.h>
1623	#ifndef __AFXTEMPL_H__
1624	#include <afxtempl.h>
1625	#endif
1626	//--------------------------------------------------------------------------------
1627	class CFileIndexSubSystem : public CChangeNotificationSubSystem
1628		{
1629		friend class CFileIndexThread;
1630		public:
1631			DECLARE_DYNAMIC(CFileIndexSubSystem);
1632		protected:
1633			CFileIndexDirObjectMap m_tree;
1634		protected:
1635			bool ParseDirectory(CString sPath, CWriteLock&);
1636		public:
1637			CFileIndexSubSystem(CSystem*);
1638			virtual ~CFileIndexSubSystem();
1639			bool ParseNewWatchPath(LPCTSTR pPath);
1640			bool AddDirectory(LPCTSTR pDir, CFileIndexDirObject*&);
1641			bool AddDirectory(LPCTSTR pDir, CFileIndexDirObject*&, CWriteLock&);
1642			bool FindDirectory(LPCTSTR pDir, CFileIndexDirObject*&);
1643			bool RemoveDirectory(LPCTSTR pDir);
1644			bool RemoveDirectory(CFileIndexDirObject*);
1645			bool AddFile(LPCTSTR pFullPathname, CFileIndexDirObject*&, CFileIndexFileObject*&);
1646			bool AddFile(LPCTSTR pFullPathname, CFileIndexDirObject*&, CFileIndexFileObject*&, CWriteLock&);
1647			bool AddFile(LPCTSTR pDir, LPCTSTR pFilename, CFileIndexDirObject*&, CFileIndexFileObject*&);
1648			bool AddFile(LPCTSTR pDir, LPCTSTR pFilename, CFileIndexDirObject*&, CFileIndexFileObject*&, CWriteLock&);
1649			bool FindFile(LPCTSTR pFullPathname, CFileIndexDirObject*&, CFileIndexFileObject*&);
1650			bool FindFile(LPCTSTR pFullPathname, CFileIndexDirObject*&, CFileIndexFileObject*&, CWriteLock&);
1651			bool FindFile(LPCTSTR pDir, LPCTSTR pFilename, CFileIndexDirObject*&, CFileIndexFileObject*&);
1652			bool FindFile(LPCTSTR pDir, LPCTSTR pFilename, CFileIndexDirObject*&, CFileIndexFileObject*&, CWriteLock&);
1653			virtual CFileIndexDirObject* CreateFileIndexDirObject(LPCTSTR pDir);
1654			virtual CFileIndexFileObject* CreateFileIndexFileObject(CFileIndexDirObject*, LPCTSTR pFilename);
1655			virtual bool WriteIndex(CFile&);
1656			virtual bool ReadIndex(CFile&);
1657	#ifdef _DEBUG
1658			void Dump(LPCTSTR pDumpFilename);
1659	#endif
1660		};
1661	#endif // !defined(AFX_FILEINDEXSUBSYSTEM_H__B66F74A9_E5CF_11D3_B10F_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: IOSubSystem.cppYYHEY

1662	//--------------------------------------------------------------------------------
1663	//
1664	// Copyright (c) 2000 @COMPANY
1665	//
1666	// Programming by Rich Schonthal
1667	//
1668	//--------------------------------------------------------------------------------
1669	#include "stdafx.h"
1670	#include "IOSubSystem.h"
1671	#include "IOThread.h"
1672	#include <QuickMail.h>
1673	#ifdef _DEBUG
1674	#undef THIS_FILE
1675	static char THIS_FILE[]=__FILE__;
1676	#define new DEBUG_NEW
1677	#endif
1678	//--------------------------------------------------------------------------------
1679	IMPLEMENT_DYNAMIC(CIOSubSystem, CThreadPoolSubSystem);
1680	//--------------------------------------------------------------------------------
1681	#ifdef _DEBUG
1682	DWORD CIOSubSystem::m_nTraceLevel = IOMASK_DEBUG;
1683	#else
1684	DWORD CIOSubSystem::m_nTraceLevel = 0;
1685	#endif
1686	CStdioFile* CIOSubSystem::m_pLogFile = NULL;
1687	CNTService* CIOSubSystem::m_pService = NULL;
1688	CMutex CIOSubSystem::m_mutexLogFile;
1689	//--------------------------------------------------------------------------------
1690	CIOSubSystem::CIOSubSystem(CSystem* pParent)
1691			: CThreadPoolSubSystem(pParent)
1692		{
1693		m_pLogFile = NULL;
1694		}
1695	//--------------------------------------------------------------------------------
1696	bool CIOSubSystem::Init()
1697		{
1698		SYSTEM_INFO info;
1699		::GetSystemInfo(&info);
1700		for(UINT i = 0; i < info.dwNumberOfProcessors; i++)
1701			AddThread(CreateThread());
1702		return true;
1703		}
1704	//--------------------------------------------------------------------------------
1705	CIOSubSystem::~CIOSubSystem()
1706		{
1707		delete m_pLogFile;
1708		}
1709	//--------------------------------------------------------------------------------
1710	CMutex& CIOSubSystem::GetLogFileLock() const
1711		{
1712		return m_mutexLogFile;
1713		}
1714	//--------------------------------------------------------------------------------
1715	CStdioFile* CIOSubSystem::GetLogFilePtr()
1716		{
1717		return m_pLogFile;
1718		}
1719	//--------------------------------------------------------------------------------
1720	void CIOSubSystem::SetServicePtr(CNTService* pService)
1721		{
1722		m_pService = pService;
1723		}
1724	//--------------------------------------------------------------------------------
1725	CNTService* CIOSubSystem::GetServicePtr() const
1726		{
1727		return m_pService;
1728		}
1729	//--------------------------------------------------------------------------------
1730	void CIOSubSystem::SetTraceLevel(DWORD nLevel)
1731		{
1732		m_nTraceLevel = nLevel;
1733		}
1734	//--------------------------------------------------------------------------------
1735	DWORD CIOSubSystem::GetTraceLevel() const
1736		{
1737		return m_nTraceLevel;
1738		}
1739	//--------------------------------------------------------------------------------
1740	bool CIOSubSystem::IsErrorMsg(DWORD nLevel)
1741		{
1742		return (nLevel & IOMASK_ERR) == IOMASK_ERR;
1743		}
1744	//--------------------------------------------------------------------------------
1745	bool CIOSubSystem::IsLogMsg(DWORD nLevel)
1746		{
1747		return (nLevel & IOMASK_LOG) == IOMASK_LOG;
1748		}
1749	//--------------------------------------------------------------------------------
1750	bool CIOSubSystem::IsDisplayed(DWORD nLevel) const
1751		{
1752		if(m_nTraceLevel == IOMASK_OFF)
1753			return false;
1754		if( (nLevel & IOMASK_ALWAYSDISPLAYMASK) != 0)
1755			return true;
1756		return (nLevel & m_nTraceLevel) != 0;
1757		}
1758	//--------------------------------------------------------------------------------
1759	bool CIOSubSystem::CloseLogFile()
1760		{
1761		CSingleLock lock(&m_mutexLogFile, false);
1762		if(! lock.Lock(10000))
1763			return false;
1764		delete m_pLogFile;
1765		m_pLogFile = NULL;
1766		return true;
1767		}
1768	//--------------------------------------------------------------------------------
1769	bool CIOSubSystem::CreateLogFile(LPCTSTR pFilename,  bool bTruncate)
1770		{
1771		if(pFilename == NULL)
1772			return false;
1773		CSingleLock lock(&m_mutexLogFile, false);
1774		if(! lock.Lock(10000))
1775			return false;
1776		delete m_pLogFile;
1777		m_pLogFile = new CStdioFile;
1778		CFileException exception;
1779		UINT nFlags = CFile::modeCreate|CFile::modeReadWrite|(bTruncate?0:CFile::modeNoTruncate)|CFile::shareDenyWrite;
1780		if(! m_pLogFile->Open(pFilename, nFlags, &exception))
1781			{
1782			SetResultCode(CResult::errOS);
1783			SetOSResult(exception.m_lOsError);
1784			return false;
1785			}
1786		if(! bTruncate)
1787			m_pLogFile->SeekToEnd();
1788		WriteLogFileHeader();
1789		return true;
1790		}
1791	//--------------------------------------------------------------------------------
1792	void CIOSubSystem::WriteLogFileHeader()
1793		{
1794		}
1795	//--------------------------------------------------------------------------------
1796	bool CIOSubSystem::Output(DWORD nFlags, LPCTSTR pText)
1797		{
1798		bool bRv = false;
1799		TCHAR* pTextCopy = NULL;
1800		if(IsDisplayed(nFlags))
1801			{
1802			if((nFlags & IOMASK_CONST) == IOMASK_CONST)
1803				return PostNextThreadMessage(MSG_OUTPUT_CONST, (WPARAM) pText, 0);
1804			else
1805				{
1806				// we must make a copy of the text because, even though its passed as const
1807				// the original may be deleted before the IO thread is thru with it
1808				int nLen = _tcslen(pText);
1809				pTextCopy = new TCHAR[nLen + 1];
1810				memcpy(pTextCopy, pText, (nLen + 1) * sizeof(TCHAR));
1811				bRv = PostNextThreadMessage(MSG_OUTPUT, (WPARAM) pTextCopy, 0);
1812				}
1813			}
1814		if(! bRv)
1815			delete[] pTextCopy;
1816		return bRv;
1817		}
1818	//--------------------------------------------------------------------------------
1819	bool CIOSubSystem::Output(DWORD nFlags, LPTSTR pText)
1820		{
1821		bool bRv = false;
1822		if(IsDisplayed(nFlags))
1823			{
1824			// non-const - pText will be deleted by pThread
1825			if((nFlags & IOMASK_CONST) == IOMASK_CONST)
1826				return PostNextThreadMessage(MSG_OUTPUT_CONST, (WPARAM) pText, 0);
1827			else
1828				bRv = PostNextThreadMessage(MSG_OUTPUT, (WPARAM) pText, 0);
1829			}
1830		if(! bRv)
1831			delete pText;
1832		return bRv;
1833		}
1834	//--------------------------------------------------------------------------------
1835	bool CIOSubSystem::FormatOutput(DWORD nFlags, LPCTSTR pFormat, ...)
1836		{
1837		if(! IsDisplayed(nFlags))
1838			return true;
1839		va_list marker;
1840		va_start(marker, pFormat);
1841		TCHAR* pTemp = new TCHAR[4096];
1842		_vstprintf(pTemp, pFormat, marker);
1843		PostNextThreadMessage(MSG_OUTPUT, (WPARAM) pTemp, 0);
1844		return true;
1845		}
1846	//--------------------------------------------------------------------------------
1847	bool CIOSubSystem::Debug(LPCTSTR pText)
1848		{
1849		return Output(IOMASK_DEBUG, pText);
1850		}
1851	//--------------------------------------------------------------------------------
1852	bool CIOSubSystem::Debug(LPTSTR pText)
1853		{
1854		return Output(IOMASK_DEBUG, pText);
1855		}
1856	//--------------------------------------------------------------------------------
1857	bool CIOSubSystem::DebugPrintf(LPCTSTR pFormat, ...)
1858		{
1859		if(! IsDisplayed(IOMASK_DEBUG))
1860			return true;
1861		va_list marker;
1862		va_start(marker, pFormat);
1863		TCHAR* pTemp = new TCHAR[4096];
1864		_vstprintf(pTemp, pFormat, marker);
1865		PostNextThreadMessage(MSG_OUTPUT, (WPARAM) pTemp, 0);
1866		return true;
1867		}
1868	//--------------------------------------------------------------------------------
1869	bool CIOSubSystem::OutputToDebugger(LPCTSTR pText)
1870		{
1871		OutputDebugString(pText);
1872		OutputDebugString(_T("\r\n"));
1873		return true;
1874		}
1875	//--------------------------------------------------------------------------------
1876	bool CIOSubSystem::OutputToFile(LPCTSTR pText, CStdioFile* pFile)
1877		{
1878		if(pFile == NULL || pText == NULL)
1879			return false;
1880		pFile->WriteString(pText);
1881		pFile->WriteString(_T("\r\n"));
1882		return true;
1883		}
1884	//--------------------------------------------------------------------------------
1885	bool CIOSubSystem::SendQuickMail(CQuickMail* pMail)
1886		{
1887		bool bRv = PostNextThreadMessage(MSG_QUICKMAIL, (WPARAM) pMail);
1888		if(! bRv)
1889			delete pMail;
1890		return bRv;
1891		}
1892	//--------------------------------------------------------------------------------
1893	CThreadObject* CIOSubSystem::CreateThread()
1894		{
1895		return (CThreadObject*) new CIOThread(this);
1896		}
1897	//--------------------------------------------------------------------------------
1898	int CIOSubSystem::GetObjectId()
1899		{
1900		return OIDTM_SUBSYSTEM + SLOID_IO;
1901		}
ZZHEYXXHEYFile: IOSubSystem.hYYHEY

1902	//--------------------------------------------------------------------------------
1903	//
1904	// Copyright (c) 2000 @COMPANY
1905	//
1906	// Programming by Rich Schonthal
1907	//
1908	//--------------------------------------------------------------------------------
1909	#ifndef _IOSUBSYSTEM_H_
1910	#define _IOSUBSYSTEM_H_
1911	#if _MSC_VER > 1000
1912	#pragma once
1913	#endif // _MSC_VER > 1000
1914	//--------------------------------------------------------------------------------
1915	#include "SubSystem.h"
1916	//--------------------------------------------------------------------------------
1917	class CNTService;
1918	class CQuickMail;
1919	//--------------------------------------------------------------------------------
1920	enum
1921		{
1922		IOMASK_OFF = 0,
1923		IOMASK_1 =		0x00000001,
1924		IOMASK_2 =		0x00000002,
1925		IOMASK_3 =		0x00000004,
1926		IOMASK_4 =		0x00000008,
1927		IOMASK_5 =		0x00000010,
1928		IOMASK_6 =		0x00000020,
1929		IOMASK_7 =		0x00000040,
1930		IOMASK_8 =		0x00000080,
1931		IOMASK_9 =		0x00000100,
1932		IOMASK_10 =		0x00000200,
1933		IOMASK_11 =		0x00000400,
1934		IOMASK_12 =		0x00000800,
1935		IOMASK_13 =		0x00001000,
1936		IOMASK_14 =		0x00002000,
1937		IOMASK_15 =		0x00004000,
1938		IOMASK_16 =		0x00008000,
1939		IOMASK_CONST =	0x01000000,
1940		IOMASK_ERR =	0x1000FFFF,
1941		IOMASK_LOG =	0x2000FFFF,
1942		IOMASK_DEBUG =	0x40000000,
1943		IOMASK_ALWAYSDISPLAYMASK = 0xFFFF0000,
1944		};
1945	//--------------------------------------------------------------------------------
1946	class CIOSubSystem : public CThreadPoolSubSystem
1947		{
1948		public:
1949			DECLARE_DYNAMIC(CIOSubSystem);
1950		friend class CIOThread;
1951		public:
1952			enum
1953				{
1954				MSG_OUTPUT = WM_USER,
1955				MSG_OUTPUT_CONST,
1956				MSG_QUICKMAIL
1957				};
1958		public:
1959			CIOSubSystem(CSystem*);
1960			virtual ~CIOSubSystem();
1961		protected:
1962			static DWORD m_nTraceLevel;
1963			static CMutex m_mutexLogFile;
1964			static CStdioFile* m_pLogFile;
1965			static CNTService* m_pService;
1966		public:
1967			virtual bool Init();
1968			virtual void SetTraceLevel(DWORD);
1969			virtual DWORD GetTraceLevel() const;
1970			static bool IsErrorMsg(DWORD);
1971			static bool IsLogMsg(DWORD);
1972			virtual bool IsDisplayed(DWORD) const;
1973			virtual void SetServicePtr(CNTService*);
1974			virtual CNTService* GetServicePtr() const;
1975			virtual bool CreateLogFile(LPCTSTR pFilename,  bool bTruncate = false);
1976			virtual bool CloseLogFile();
1977			virtual CStdioFile* GetLogFilePtr();
1978			virtual CMutex& GetLogFileLock() const;
1979			virtual bool Output(DWORD, LPCTSTR);
1980			virtual bool Output(DWORD, LPTSTR);
1981			virtual bool FormatOutput(DWORD, LPCTSTR, ...);
1982			virtual bool Debug(LPCTSTR);
1983			virtual bool Debug(LPTSTR);
1984			virtual bool DebugPrintf(LPCTSTR, ...);
1985			virtual bool SendQuickMail(CQuickMail*);
1986		protected:
1987			virtual void WriteLogFileHeader();
1988			virtual bool OutputToDebugger(LPCTSTR);
1989			virtual bool OutputToFile(LPCTSTR, CStdioFile*);
1990			virtual CThreadObject* CreateThread();
1991			virtual int GetObjectId();
1992		};
1993	#endif // _IOSUBSYSTEM_H_
ZZHEYXXHEYFile: IOThread.cppYYHEY

1994	//--------------------------------------------------------------------------------
1995	//
1996	// Copyright (c) 2000 @COMPANY
1997	//
1998	// Programming by Rich Schonthal
1999	//
2000	//--------------------------------------------------------------------------------
2001	#include "stdafx.h"
2002	#include "IOThread.h"
2003	#include "IOSubSystem.h"
2004	#include "NTService.h"
2005	#include <QuickMail.h>
2006	#ifdef _DEBUG
2007	#undef THIS_FILE
2008	static char THIS_FILE[]=__FILE__;
2009	#define new DEBUG_NEW
2010	#endif
2011	IMPLEMENT_DYNAMIC(CIOThread, CSystemObject)
2012	//--------------------------------------------------------------------------------
2013	CIOThread::CIOThread(CIOSubSystem* pParent)
2014			: CTypedThreadObject<CSystem, CIOSubSystem>(pParent)
2015		{
2016		}
2017	//--------------------------------------------------------------------------------
2018	CIOThread::~CIOThread()
2019		{
2020		}
2021	//--------------------------------------------------------------------------------
2022	void CIOThread::Exit(bool)
2023		{
2024		MSG msg;
2025		while(PeekMessage(&msg, NULL, CIOSubSystem::MSG_OUTPUT, 0, PM_REMOVE))
2026			delete[] (LPTSTR) msg.wParam;
2027		while(PeekMessage(&msg, NULL, CIOSubSystem::MSG_QUICKMAIL, 0, PM_REMOVE))
2028			delete reinterpret_cast<CQuickMail*>(msg.wParam);
2029		}
2030	//--------------------------------------------------------------------------------
2031	void CIOThread::OnMessage(UINT nMsg, WPARAM param, LPARAM)
2032		{
2033		LPTSTR pText = (LPTSTR) param;
2034		switch(nMsg)
2035			{
2036			case CIOSubSystem::MSG_OUTPUT:
2037				Output(pText);
2038				delete[] pText;
2039				break;
2040			case CIOSubSystem::MSG_OUTPUT_CONST:
2041				Output(pText);
2042				break;
2043			case CIOSubSystem::MSG_QUICKMAIL:
2044				{
2045				CQuickMail* pQm = reinterpret_cast<CQuickMail*>(param);
2046				if(pQm != NULL)
2047					{
2048					pQm->Send();
2049					delete pQm;
2050					}
2051				}
2052				break;
2053			}
2054		}
2055	//--------------------------------------------------------------------------------
2056	void CIOThread::Output(LPCTSTR pText)
2057		{
2058		CSingleLock* pLock = NULL;
2059		CStdioFile* pFile = NULL;
2060		if(GetSubSystem()->GetLogFilePtr() != NULL)
2061			{
2062			pLock = new CSingleLock(&GetSubSystem()->GetLogFileLock(), false);
2063			if(! pLock->Lock())
2064				{
2065				delete pLock;
2066				pLock = NULL;
2067				}
2068			else
2069				pFile = GetSubSystem()->GetLogFilePtr();
2070			}
2071		if(pFile != NULL)
2072			GetSubSystem()->OutputToFile(pText, pFile);
2073		delete pLock;
2074		if((GetSubSystem()->GetTraceLevel() & IOMASK_DEBUG) == IOMASK_DEBUG)
2075			GetSubSystem()->OutputToDebugger(pText);
2076		CNTService* pService = GetSubSystem()->GetServicePtr();
2077		if(pService != NULL)
2078			pService->AddToMessageLog(pText);
2079		}
2080	//--------------------------------------------------------------------------------
2081	void CIOThread::AcknowledgeStateChange()
2082		{
2083		CSystemObject::AcknowledgeStateChange();
2084		}
2085	//--------------------------------------------------------------------------------
2086	int CIOThread::GetObjectId()
2087		{
2088		return OIDTM_THREAD + SLOID_IO;
2089		}
ZZHEYXXHEYFile: IOThread.hYYHEY

2090	//--------------------------------------------------------------------------------
2091	//
2092	// Copyright (c) 2000 @COMPANY
2093	//
2094	// Programming by Rich Schonthal
2095	//
2096	//--------------------------------------------------------------------------------
2097	#if !defined(AFX_IOTHREAD_H__C10D0D11_CF6E_11D3_AF12_005004A1C5F3__INCLUDED_)
2098	#define AFX_IOTHREAD_H__C10D0D11_CF6E_11D3_AF12_005004A1C5F3__INCLUDED_
2099	#if _MSC_VER > 1000
2100	#pragma once
2101	#endif // _MSC_VER > 1000
2102	//--------------------------------------------------------------------------------
2103	#include "ThreadObject.h"
2104	class CIOSubSystem;
2105	//--------------------------------------------------------------------------------
2106	class CIOThread : public CTypedThreadObject<CSystem, CIOSubSystem>
2107		{
2108		DECLARE_DYNAMIC(CIOThread);
2109		public:
2110			CIOThread(CIOSubSystem*);
2111			virtual ~CIOThread();
2112			virtual void Exit(bool);
2113	//		CIOSubSystem* GetSubSystem()	{ return (CIOSubSystem*) CThreadObject::GetSubSystem(); }
2114			virtual void OnMessage(UINT, WPARAM, LPARAM);
2115			virtual void Output(LPCTSTR);
2116			// called by state clients to acknowldge state change
2117			virtual void AcknowledgeStateChange();
2118			virtual int GetObjectId();
2119		};
2120	#endif // !defined(AFX_IOTHREAD_H__C10D0D11_CF6E_11D3_AF12_005004A1C5F3__INCLUDED_)
ZZHEYXXHEYFile: LockObject.cppYYHEY

2121	//--------------------------------------------------------------------------------
2122	//
2123	// Copyright (c) 1999 @COMPANY
2124	//
2125	// Programming by Rich Schonthal
2126	//
2127	//--------------------------------------------------------------------------------
2128	//--------------------------------------------------------------------------------
2129	#include "stdafx.h"
2130	#include "LockObject.h"
2131	//--------------------------------------------------------------------------------
2132	CLockObject::CLockObject(CSyncObject* pLock, DWORD nFlags)
2133		{
2134		m_pLock = pLock;
2135		m_nFlags = nFlags;
2136		}
2137	//--------------------------------------------------------------------------------
2138	CLockObject::~CLockObject()
2139		{
2140		if((m_nFlags & AUTO_DELETE) == AUTO_DELETE)
2141			{
2142			delete m_pLock;
2143			m_pLock = NULL;
2144			}
2145		}
2146	//--------------------------------------------------------------------------------
2147	CSyncObject* CLockObject::GetLockPtr()
2148		{
2149		return m_pLock;
2150		}
2151	//--------------------------------------------------------------------------------
2152	void CLockObject::SetLockPtr(CSyncObject* pLock, DWORD nFlags)
2153		{
2154		m_pLock = pLock;
2155		m_nFlags = nFlags;
2156		}
2157	//--------------------------------------------------------------------------------
2158	HANDLE CLockObject::GetLockHandle()
2159		{
2160		if(m_pLock == NULL)
2161			return INVALID_HANDLE_VALUE;
2162		return *m_pLock;
2163		}
ZZHEYXXHEYFile: LockObject.hYYHEY

2164	//--------------------------------------------------------------------------------
2165	//
2166	// Copyright (c) 1999 @COMPANY
2167	//
2168	// Programming by Rich Schonthal
2169	//
2170	//--------------------------------------------------------------------------------
2171	#if !defined(AFX_LOCKOBJECT_H__3DB04CE3_888A_11D3_AF00_005004A1C5F3__INCLUDED_)
2172	#define AFX_LOCKOBJECT_H__3DB04CE3_888A_11D3_AF00_005004A1C5F3__INCLUDED_
2173	#if _MSC_VER > 1000
2174	#pragma once
2175	#endif // _MSC_VER > 1000
2176	//--------------------------------------------------------------------------------
2177	class CLockObject
2178		{
2179		public:
2180			enum
2181				{
2182				AUTO_DELETE = 1
2183				};
2184		protected:
2185			CSyncObject* m_pLock;
2186			DWORD m_nFlags;
2187		public:
2188			CLockObject(CSyncObject* = NULL, DWORD = 0);
2189			virtual ~CLockObject();
2190		public:
2191			CSyncObject* GetLockPtr();
2192			void SetLockPtr(CSyncObject*, DWORD = 0);
2193			HANDLE GetLockHandle();
2194		};
2195	#endif // !defined(AFX_LOCKOBJECT_H__3DB04CE3_888A_11D3_AF00_005004A1C5F3__INCLUDED_)
ZZHEYXXHEYFile: NTService.cppYYHEY

2196	//--------------------------------------------------------------------------------
2197	//
2198	// Copyright (c) 1999 @COMPANY
2199	//
2200	// Programming by Rich Schonthal
2201	//
2202	//--------------------------------------------------------------------------------
2203	#include "stdafx.h"
2204	#include "NTService.h"
2205	#include <CmdLine.h>
2206	#include <allocstring.h>
2207	#include <status.h>
2208	#include <PlatformInfo.h>
2209	#include <DebugPrintf.h>
2210	#include <CmdLine.h>
2211	// define this when building a DLL service
2212	//#define AFX_MANAGE_STATE_IF_DLL AFX_MANAGE_STATE(AfxGetStaticModuleState());
2213	#define AFX_MANAGE_STATE_IF_DLL
2214	//--------------------------------------------------------------------------------
2215	static CNTService* g_this = 0;
2216	static LPCTSTR g_pAppRegKey = TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");
2217	//--------------------------------------------------------------------------------
2218	CNTService::CNTService(CWinApp* pMainApp)
2219			: m_dwErr(0)
2220			, m_sshStatusHandle(0)
2221			, m_pUserSID(0)
2222			, m_dwTagID(0)
2223			, m_pMainApp(pMainApp)
2224		{
2225		AFX_MANAGE_STATE_IF_DLL
2226		CPlatformInfo winVer;
2227		// must be running on NT
2228		if(! winVer.IsWinNT())
2229			return;
2230		g_this = this;
2231		// SERVICE_STATUS members that rarely change
2232		m_ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
2233		m_ssStatus.dwServiceSpecificExitCode = 0;
2234		// Get security information of current user
2235		BYTE nSecurityIdBuffer[4096];
2236		DWORD dwSizeSecurityIdBuffer = sizeof(nSecurityIdBuffer);
2237		TCHAR sUserName[256];
2238		DWORD dwSizeUserName  =  255;
2239		TCHAR sDomainName[256];
2240		DWORD dwSizeDomainName = 255;
2241		SID_NAME_USE sidTypeSecurityId;
2242		::ZeroMemory(sUserName, sizeof(sUserName));
2243		::ZeroMemory(sDomainName, sizeof(sDomainName));
2244		::ZeroMemory(nSecurityIdBuffer, dwSizeSecurityIdBuffer);
2245		::GetUserName(sUserName, &dwSizeUserName);
2246		if(::LookupAccountName(0, sUserName, &nSecurityIdBuffer, &dwSizeSecurityIdBuffer, sDomainName, &dwSizeDomainName,
2247					&sidTypeSecurityId))
2248			{
2249			if(::IsValidSid( PSID(nSecurityIdBuffer)))
2250				{
2251				DWORD dwSidLen = ::GetLengthSid(PSID(nSecurityIdBuffer));
2252				m_pUserSID = PSID(new BYTE [dwSidLen]);
2253				::CopySid(dwSidLen, m_pUserSID, nSecurityIdBuffer);
2254				_ASSERTE(::EqualSid(m_pUserSID, nSecurityIdBuffer));
2255				}
2256			}
2257		}
2258	//--------------------------------------------------------------------------------
2259	CNTService::~CNTService()
2260		{
2261		AFX_MANAGE_STATE_IF_DLL
2262		ReportStatus(SERVICE_STOPPED);
2263		g_this = NULL;
2264		delete[] LPBYTE(m_pUserSID);
2265		}
2266	//--------------------------------------------------------------------------------
2267	BOOL CNTService::ProcessCommandLine()
2268		{
2269		return ProcessCommandLine(::GetCommandLine());
2270		}
2271	//--------------------------------------------------------------------------------
2272	BOOL CNTService::ProcessCommandLine(LPCTSTR pCmdLine)
2273		{
2274		AFX_MANAGE_STATE_IF_DLL
2275		CCmdLine cmdLine(pCmdLine);
2276		int nIndex;
2277		if(cmdLine.HasParam('D', nIndex) || cmdLine.HasParam(_T("-debug"), nIndex))
2278			return FALSE;
2279		if(cmdLine.HasParam('I', nIndex) || cmdLine.HasParam(_T("-install"), nIndex))
2280			{
2281			InstallService();
2282			return TRUE;
2283			}
2284		if(cmdLine.HasParam('R', nIndex) || cmdLine.HasParam(_T("-remove"), nIndex))
2285			{
2286			RemoveService();
2287			return TRUE;
2288			}
2289		if(cmdLine.HasParam('E', nIndex) || cmdLine.HasParam(_T("-end"), nIndex) || cmdLine.HasParam(_T("-stop"), nIndex))
2290			{
2291			EndService();
2292			return TRUE;
2293			}
2294		if(cmdLine.HasParam('S', nIndex) || cmdLine.HasParam(_T("-start"), nIndex))
2295			{
2296			StartupService();
2297			return TRUE;
2298			}
2299		return FALSE;
2300		}
2301	//--------------------------------------------------------------------------------
2302	BOOL CNTService::StartDispatcher()
2303		{
2304		AFX_MANAGE_STATE_IF_DLL
2305		// Default implementation creates a single threaded service.
2306		// Override this method and provide more table entries for
2307		// a multithreaded service (one entry for each thread).
2308		SERVICE_TABLE_ENTRY dispatchTable[] =
2309			{
2310				{ LPTSTR(GetServiceName()), (LPSERVICE_MAIN_FUNCTION)ServiceMain },
2311				{ 0, 0 }
2312			};
2313		if(! StartServiceCtrlDispatcher(dispatchTable))
2314			{
2315			DebugPrintf("StartServiceCtrlDispatcher err %d\n", GetLastError());
2316			return false;
2317			}
2318		return true;
2319		}
2320	//--------------------------------------------------------------------------------
2321	BOOL CNTService::InstallService()
2322		{
2323		AFX_MANAGE_STATE_IF_DLL
2324		TCHAR szPath[1024];
2325		if(GetModuleFileName( 0, szPath, 1023 ) == 0 )
2326			return FALSE;
2327		BOOL bRet = FALSE;
2328		SC_HANDLE schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
2329		if(schSCManager != NULL)
2330			{
2331			DWORD nServiceType = GetServiceType();
2332			DWORD nStartType = GetStartType();
2333			SC_HANDLE schService =	CreateService(
2334										schSCManager,
2335										GetServiceName(),
2336										GetDisplayName(),
2337										GetDesiredAccess(),
2338										nServiceType,
2339										nStartType,
2340										GetErrorControl(),
2341										szPath,
2342										GetLoadOrderGroup(),
2343										((nServiceType == SERVICE_KERNEL_DRIVER ||
2344										  nServiceType == SERVICE_FILE_SYSTEM_DRIVER) &&
2345										 (nStartType == SERVICE_BOOT_START ||
2346										  nStartType == SERVICE_SYSTEM_START)) ?
2347											&m_dwTagID : NULL,
2348										GetDependencies(),
2349										GetUserName(),
2350										GetPassword()
2351									);
2352			if(schService != NULL)
2353				{
2354				CloseServiceHandle(schService);
2355				bRet = TRUE;
2356				}
2357			CloseServiceHandle(schSCManager);
2358			}
2359		if(bRet)
2360			// installation succeeded. Now register the message file
2361			RegisterApplicationLog(szPath, EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE);
2362		return bRet;
2363		}
2364	//--------------------------------------------------------------------------------
2365	BOOL CNTService::RemoveService()
2366		{
2367		AFX_MANAGE_STATE_IF_DLL
2368		BOOL bRet = FALSE;
2369		SC_HANDLE schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
2370		if(schSCManager != NULL)
2371			{
2372			SC_HANDLE schService =	OpenService(schSCManager, GetServiceName(), SERVICE_ALL_ACCESS);
2373			if(schService != NULL)
2374				{
2375				// try to stop the service
2376				if(ControlService(schService, SERVICE_CONTROL_STOP, &m_ssStatus) )
2377					{
2378					Sleep(1000);
2379					while(QueryServiceStatus(schService, &m_ssStatus) )
2380						{
2381						if(m_ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
2382							::Sleep(1000);
2383						else
2384							break;
2385						}
2386					}
2387				// now remove the service
2388				bRet = DeleteService(schService) != 0;
2389				CloseServiceHandle(schService);
2390				}
2391			CloseServiceHandle(schSCManager);
2392			}
2393		if(bRet)
2394			DeregisterApplicationLog();
2395		return bRet;
2396		}
2397	//--------------------------------------------------------------------------------
2398	BOOL CNTService::EndService()
2399		{
2400		AFX_MANAGE_STATE_IF_DLL
2401		BOOL bRet = FALSE;
2402		SC_HANDLE schSCManager = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
2403		if(schSCManager != NULL)
2404			{
2405			SC_HANDLE schService =	::OpenService(schSCManager, GetServiceName(), SERVICE_ALL_ACCESS);
2406			if(schService != NULL)
2407				{
2408				// try to stop the service
2409				if(::ControlService(schService, SERVICE_CONTROL_STOP, &m_ssStatus))
2410					{
2411					::Sleep(1000);
2412					while(::QueryServiceStatus(schService, &m_ssStatus))
2413						{
2414						if(m_ssStatus.dwCurrentState == SERVICE_STOP_PENDING)
2415							::Sleep(1000);
2416						else
2417							break;
2418						}
2419					bRet = (m_ssStatus.dwCurrentState == SERVICE_STOPPED);
2420					}
2421				::CloseServiceHandle(schService);
2422				}
2423			::CloseServiceHandle(schSCManager);
2424			}
2425		return bRet;
2426		}
2427	//--------------------------------------------------------------------------------
2428	BOOL CNTService::StartupService()
2429		{
2430		AFX_MANAGE_STATE_IF_DLL
2431		BOOL bRet = FALSE;
2432		SC_HANDLE schSCManager = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
2433		if(schSCManager != NULL)
2434			{
2435			QUERY_SERVICE_CONFIG serviceConfig;
2436			::QueryServiceConfig(schSCManager, &serviceConfig, sizeof(serviceConfig), NULL);
2437			SC_HANDLE schService =	::OpenService(schSCManager, GetServiceName(), SERVICE_ALL_ACCESS);
2438			if(schService != NULL)
2439				{
2440				// try to start the service
2441				if(::StartService(schService, 0, 0) )
2442					{
2443					Sleep(1000);
2444					while(::QueryServiceStatus(schService, &m_ssStatus) )
2445						{
2446						if(m_ssStatus.dwCurrentState == SERVICE_START_PENDING )
2447							::Sleep(1000);
2448						else
2449							break;
2450						}
2451					bRet = (m_ssStatus.dwCurrentState == SERVICE_RUNNING);
2452					}
2453				::CloseServiceHandle(schService);
2454				}
2455			::CloseServiceHandle(schSCManager);
2456			}
2457		return bRet;
2458		}
2459	//--------------------------------------------------------------------------------
2460	DWORD CNTService::GetStopPendingTime()
2461		{
2462		return 5000;
2463		}
2464	//--------------------------------------------------------------------------------
2465	DWORD CNTService::GetPausePendingTime()
2466		{
2467		return 1000;
2468		}
2469	//--------------------------------------------------------------------------------
2470	DWORD CNTService::GetContinuePendingTime()
2471		{
2472		return 1000;
2473		}
2474	//--------------------------------------------------------------------------------
2475	void CNTService::Stop()
2476		{
2477		AFX_MANAGE_STATE_IF_DLL
2478		if(m_pMainApp == NULL)
2479			return;
2480		ReportStatus(SERVICE_STOP_PENDING, GetStopPendingTime());
2481		m_pMainApp->PostThreadMessage(MSG_STOP, 0, 0);
2482		}
2483	//--------------------------------------------------------------------------------
2484	void CNTService::Pause()
2485		{
2486		AFX_MANAGE_STATE_IF_DLL
2487		if(m_pMainApp == NULL)
2488			return;
2489		ReportStatus(SERVICE_PAUSE_PENDING, GetPausePendingTime());
2490		m_pMainApp->PostThreadMessage(MSG_PAUSE, 0, 0);
2491		}
2492	//--------------------------------------------------------------------------------
2493	void CNTService::Continue()
2494		{
2495		AFX_MANAGE_STATE_IF_DLL
2496		if(m_pMainApp == NULL)
2497			return;
2498		ReportStatus(SERVICE_CONTINUE_PENDING, GetContinuePendingTime());
2499		m_pMainApp->PostThreadMessage(MSG_CONTINUE, 0, 0);
2500		}
2501	//--------------------------------------------------------------------------------
2502	void CNTService::Shutdown()
2503		{
2504		AFX_MANAGE_STATE_IF_DLL
2505		if(m_pMainApp == NULL)
2506			return;
2507		ReportStatus(SERVICE_STOP_PENDING, GetStopPendingTime());
2508		m_pMainApp->PostThreadMessage(MSG_SHUTDOWN, 0, 0);
2509		}
2510	//--------------------------------------------------------------------------------
2511	void WINAPI CNTService::ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)
2512		{
2513		AFX_MANAGE_STATE_IF_DLL
2514		// register our service control handler:
2515		g_this->m_sshStatusHandle =
2516			RegisterServiceCtrlHandler(g_this->GetServiceName(),CNTService::ServiceCtrl);
2517		g_this->ReportStatus(SERVICE_START_PENDING, 30000);
2518		}
2519	//--------------------------------------------------------------------------------
2520	void WINAPI CNTService::ServiceCtrl(DWORD nCtrlCode)
2521		{
2522		AFX_MANAGE_STATE_IF_DLL
2523		_ASSERTE( g_this != NULL );
2524		// Handle the requested control code.
2525		switch(nCtrlCode)
2526			{
2527			case SERVICE_CONTROL_STOP:
2528				// Stop the service.
2529				g_this->m_ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
2530				g_this->Stop();
2531				break;
2532			case SERVICE_CONTROL_PAUSE:
2533				g_this->m_ssStatus.dwCurrentState = SERVICE_PAUSE_PENDING;
2534				g_this->Pause();
2535				break;
2536			case SERVICE_CONTROL_CONTINUE:
2537				g_this->m_ssStatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
2538				g_this->Continue();
2539				break;
2540			case SERVICE_CONTROL_SHUTDOWN:
2541				g_this->Shutdown();
2542				break;
2543			case SERVICE_CONTROL_INTERROGATE:
2544				// Update the service status.
2545				g_this->ReportStatus(g_this->m_ssStatus.dwCurrentState);
2546				break;
2547			default:
2548				break;
2549			}
2550		}
2551	//--------------------------------------------------------------------------------
2552	BOOL CNTService::ReportStatus(DWORD dwCurrentState, DWORD dwWaitHint, DWORD dwErrExit)
2553		{
2554		AFX_MANAGE_STATE_IF_DLL
2555		BOOL fResult = TRUE;
2556		m_ssStatus.dwControlsAccepted = GetControlsAccepted();
2557		m_ssStatus.dwCurrentState = dwCurrentState;
2558		m_ssStatus.dwWin32ExitCode = NO_ERROR;
2559		m_ssStatus.dwWaitHint = dwWaitHint;
2560		m_ssStatus.dwServiceSpecificExitCode = dwErrExit;
2561		if (dwErrExit!=0)
2562			m_ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
2563		if(dwCurrentState == SERVICE_RUNNING || dwCurrentState == SERVICE_STOPPED)
2564			m_ssStatus.dwCheckPoint = 0;
2565		else
2566			m_ssStatus.dwCheckPoint = GetServiceCheckPoint();
2567		// Report the status of the service to the service control manager.
2568		if(!(fResult = SetServiceStatus( m_sshStatusHandle, &m_ssStatus)))
2569			{
2570			TCHAR szErr[256];
2571			DebugPrintf(_T("SetServiceStatus() failed %s\n"), GetLastErrorText(szErr,255));
2572			}
2573		return fResult;
2574		}
2575	//--------------------------------------------------------------------------------
2576	void CNTService::AddToMessageLog(LPCTSTR lpszMsg, WORD wEventType, DWORD dwEventID)
2577		{
2578		AFX_MANAGE_STATE_IF_DLL
2579		m_dwErr = GetLastError();
2580		// Use event logging to log the error.
2581		HANDLE hEventSource = RegisterEventSource(0, GetServiceName());
2582		if(hEventSource != 0 )
2583			{
2584			LPCTSTR lpszMessage = lpszMsg;
2585			ReportEvent(
2586				hEventSource,	// handle of event source
2587				wEventType,		// event type
2588				0,				// event category
2589				dwEventID,		// event ID
2590				m_pUserSID,		// current user's SID
2591				1,				// strings in lpszStrings
2592				0,				// no bytes of raw data
2593				&lpszMessage,	// array of error strings
2594				0				// no raw data
2595			);
2596			::DeregisterEventSource(hEventSource);
2597			}
2598		}
2599	//--------------------------------------------------------------------------------
2600	LPTSTR CNTService::GetLastErrorText(LPTSTR lpszBuf, DWORD dwSize)
2601		{
2602		AFX_MANAGE_STATE_IF_DLL
2603		DWORD nErr = GetLastError();
2604		LPTSTR lpszTemp = 0;
2605		DWORD dwRet =	::FormatMessage(
2606							FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
2607							0,
2608							nErr,
2609							LANG_NEUTRAL,
2610							(LPTSTR)&lpszTemp,
2611							0,
2612							0
2613						);
2614		if(!dwRet || (dwSize < dwRet+14) )
2615			lpszBuf[0] = TEXT('\0');
2616		else
2617			{
2618			lpszTemp[_tcsclen(lpszTemp)-2] = TEXT('\0');  //remove cr/nl characters
2619			_tcscpy(lpszBuf, lpszTemp);
2620			}
2621		if(lpszTemp )
2622			LocalFree(HLOCAL(lpszTemp));
2623		return lpszBuf;
2624		}
2625	//--------------------------------------------------------------------------------
2626	void CNTService::RegisterApplicationLog( LPCTSTR lpszFileName, DWORD dwTypes )
2627		{
2628		AFX_MANAGE_STATE_IF_DLL
2629		TCHAR szKey[256];
2630		_tcscpy(szKey, g_pAppRegKey);
2631		_tcscat(szKey, GetServiceName());
2632		HKEY hKey = 0;
2633		LONG lRet = ERROR_SUCCESS;
2634		// Create a key for that application and insert values for
2635		// "EventMessageFile" and "TypesSupported"
2636		if(::RegCreateKey(HKEY_LOCAL_MACHINE, szKey, &hKey) == ERROR_SUCCESS )
2637			{
2638			lRet =	::RegSetValueEx(
2639						hKey,						// handle of key to set value for
2640						TEXT("EventMessageFile"),	// address of value to set
2641						0,							// reserved
2642						REG_EXPAND_SZ,				// flag for value type
2643						(CONST BYTE*)lpszFileName,	// address of value data
2644						_tcslen(lpszFileName) + 1	// size of value data
2645					);
2646			// Set the supported types flags.
2647			lRet =	::RegSetValueEx(
2648						hKey,					// handle of key to set value for
2649						TEXT("TypesSupported"),	// address of value to set
2650						0,						// reserved
2651						REG_DWORD,				// flag for value type
2652						(CONST BYTE*)&dwTypes,	// address of value data
2653						sizeof(DWORD)			// size of value data
2654					);
2655			::RegCloseKey(hKey);
2656			}
2657		// Add the service to the "Sources" value
2658		lRet =	::RegOpenKeyEx(
2659					HKEY_LOCAL_MACHINE,	// handle of open key
2660					g_pAppRegKey,		// address of name of subkey to open
2661					0,					// reserved
2662					KEY_ALL_ACCESS,		// security access mask
2663					&hKey				// address of handle of open key
2664				);
2665		if(lRet == ERROR_SUCCESS )
2666			{
2667			DWORD dwSize;
2668			// retrieve the size of the needed value
2669			lRet =	::RegQueryValueEx(
2670						hKey,			// handle of key to query
2671						TEXT("Sources"),// address of name of value to query
2672						0,				// reserved
2673						0,				// address of buffer for value type
2674						0,				// address of data buffer
2675						&dwSize			// address of data buffer size
2676					);
2677	 		if(lRet == ERROR_SUCCESS )
2678				{
2679				DWORD dwType;
2680				DWORD dwNewSize = dwSize+_tcslen(GetServiceName())+1;
2681				LPBYTE Buffer = LPBYTE(::GlobalAlloc(GPTR, dwNewSize));
2682				lRet =	::RegQueryValueEx(
2683							hKey,			// handle of key to query
2684							TEXT("Sources"),// address of name of value to query
2685							0,				// reserved
2686							&dwType,		// address of buffer for value type
2687							Buffer,			// address of data buffer
2688							&dwSize			// address of data buffer size
2689						);
2690				if(lRet == ERROR_SUCCESS )
2691					{
2692					_ASSERTE(dwType == REG_MULTI_SZ);
2693					// check whether this service is already a known source
2694					register LPTSTR p = LPTSTR(Buffer);
2695					for(; *p; p += _tcslen(p)+1 )
2696						{
2697						if(_tcscmp(p, GetServiceName()) == 0 )
2698							break;
2699						}
2700					if(! *p)
2701						{
2702						// We're at the end of the stringarray
2703						// and the service does still not exist in the "Sources".
2704						// Now insert it at this point.
2705						// Note that we have already enough memory allocated
2706						// (see GlobalAlloc() above). We also don't need to append
2707						// an additional '\0'. This is done in GlobalAlloc() above
2708						// too.
2709						_tcscpy(p, GetServiceName());
2710						// OK - now store the modified value back into the
2711						// registry.
2712						lRet =	::RegSetValueEx(
2713									hKey,			// handle of key to set value for
2714									TEXT("Sources"),// address of value to set
2715									0,				// reserved
2716									dwType,			// flag for value type
2717									Buffer,			// address of value data
2718									dwNewSize		// size of value data
2719								);
2720						}
2721					}
2722				::GlobalFree(HGLOBAL(Buffer));
2723				}
2724			::RegCloseKey(hKey);
2725			}
2726		}
2727	//--------------------------------------------------------------------------------
2728	void CNTService::DeregisterApplicationLog()
2729		{
2730		AFX_MANAGE_STATE_IF_DLL
2731		TCHAR szKey[256];
2732		_tcscpy(szKey, g_pAppRegKey);
2733		_tcscat(szKey, GetServiceName());
2734		HKEY hKey = 0;
2735		LONG lRet = ERROR_SUCCESS;
2736		lRet = ::RegDeleteKey(HKEY_LOCAL_MACHINE, szKey);
2737		// now we have to delete the application from the "Sources" value too.
2738		lRet =	::RegOpenKeyEx(
2739					HKEY_LOCAL_MACHINE,	// handle of open key
2740					g_pAppRegKey,		// address of name of subkey to open
2741					0,					// reserved
2742					KEY_ALL_ACCESS,		// security access mask
2743					&hKey				// address of handle of open key
2744				);
2745		if(lRet == ERROR_SUCCESS )
2746			{
2747			DWORD dwSize;
2748			// retrieve the size of the needed value
2749			lRet =	::RegQueryValueEx(
2750						hKey,			// handle of key to query
2751						TEXT("Sources"),// address of name of value to query
2752						0,				// reserved
2753						0,				// address of buffer for value type
2754						0,				// address of data buffer
2755						&dwSize			// address of data buffer size
2756					);
2757	 		if(lRet == ERROR_SUCCESS )
2758				{
2759				DWORD dwType;
2760				LPBYTE Buffer = LPBYTE(::GlobalAlloc(GPTR, dwSize));
2761				LPBYTE NewBuffer = LPBYTE(::GlobalAlloc(GPTR, dwSize));
2762				lRet =	::RegQueryValueEx(
2763							hKey,			// handle of key to query
2764							TEXT("Sources"),// address of name of value to query
2765							0,				// reserved
2766							&dwType,		// address of buffer for value type
2767							Buffer,			// address of data buffer
2768							&dwSize			// address of data buffer size
2769						);
2770				if(lRet == ERROR_SUCCESS )
2771					{
2772					_ASSERTE(dwType == REG_MULTI_SZ);
2773					// check whether this service is already a known source
2774					register LPTSTR p = LPTSTR(Buffer);
2775					register LPTSTR pNew = LPTSTR(NewBuffer);
2776					BOOL bNeedSave = FALSE;	// assume the value is already correct
2777					for(; *p; p += _tcslen(p)+1)
2778						{
2779						// except ourself: copy the source string into the destination
2780						if(_tcscmp(p, GetServiceName()) != 0 )
2781							{
2782							_tcscpy(pNew, p);
2783							pNew += _tcslen(pNew)+1;
2784							}
2785						else
2786							{
2787							bNeedSave = TRUE;		// *this* application found
2788							dwSize -= _tcslen(p)+1;	// new size of value
2789							}
2790						}
2791					if(bNeedSave)
2792						{
2793						// OK - now store the modified value back into the
2794						// registry.
2795						lRet =	::RegSetValueEx(
2796									hKey,			// handle of key to set value for
2797									TEXT("Sources"),// address of value to set
2798									0,				// reserved
2799									dwType,			// flag for value type
2800									NewBuffer,		// address of value data
2801									dwSize			// size of value data
2802								);
2803						}
2804					}
2805				::GlobalFree(HGLOBAL(Buffer));
2806				::GlobalFree(HGLOBAL(NewBuffer));
2807				}
2808			::RegCloseKey(hKey);
2809			}
2810		}
2811	//--------------------------------------------------------------------------------
2812	LPCTSTR CNTService::GetServiceName()
2813		{
2814		return _T("AAAA Important NT Service");
2815		}
2816	//--------------------------------------------------------------------------------
2817	LPCTSTR CNTService::GetDisplayName()
2818		{
2819		return _T("AAAA Important NT Service");
2820		}
2821	//--------------------------------------------------------------------------------
2822	DWORD CNTService::GetControlsAccepted()
2823		{
2824		return SERVICE_ACCEPT_STOP|SERVICE_ACCEPT_PAUSE_CONTINUE;
2825		}
2826	//--------------------------------------------------------------------------------
2827	DWORD CNTService::GetServiceCheckPoint()
2828		{
2829		return 0;
2830		}
2831	//--------------------------------------------------------------------------------
2832	DWORD CNTService::GetDesiredAccess()
2833		{
2834		return SERVICE_ALL_ACCESS;
2835		}
2836	//--------------------------------------------------------------------------------
2837	DWORD CNTService::GetServiceType()
2838		{
2839		return SERVICE_WIN32_OWN_PROCESS;
2840		}
2841	//--------------------------------------------------------------------------------
2842	DWORD CNTService::GetStartType()
2843		{
2844		return SERVICE_AUTO_START;
2845		}
2846	//--------------------------------------------------------------------------------
2847	DWORD CNTService::GetErrorControl()
2848		{
2849		return SERVICE_ERROR_NORMAL;
2850		}
2851	//--------------------------------------------------------------------------------
2852	LPCTSTR CNTService::GetLoadOrderGroup()
2853		{
2854		return NULL;
2855		}
2856	//--------------------------------------------------------------------------------
2857	LPCTSTR CNTService::GetDependencies()
2858		{
2859		return NULL;
2860		}
2861	//--------------------------------------------------------------------------------
2862	LPCTSTR CNTService::GetUserName()
2863		{
2864		return NULL;
2865		}
2866	//--------------------------------------------------------------------------------
2867	LPCTSTR CNTService::GetPassword()
2868		{
2869		return NULL;
2870		}
2871	//--------------------------------------------------------------------------------
2872	UINT CNTService::ServiceThread(CNTService* that)
2873		{
2874		AFX_MANAGE_STATE_IF_DLL
2875		UINT nRv = 0;
2876		if(! that->StartDispatcher())
2877			nRv = 1;
2878		DebugPrintf("stopping\n");
2879		that->ReportStatus(SERVICE_STOP_PENDING);
2880		if(AfxGetApp() != NULL)
2881			AfxGetApp()->PostThreadMessage(WM_QUIT, 0, 0);
2882		return nRv;
2883		}
ZZHEYXXHEYFile: NTService.hYYHEY

2884	//--------------------------------------------------------------------------------
2885	//
2886	// Copyright (c) 2000 @COMPANY
2887	//
2888	// Programming by Rich Schonthal
2889	//
2890	//--------------------------------------------------------------------------------
2891	#ifndef NTService_h
2892	#define NTService_h
2893	#include <winsvc.h>
2894	//--------------------------------------------------------------------------------
2895	class CNTService
2896		{
2897		public:
2898			enum
2899				{
2900				MSG_PAUSE = WM_USER + 200,
2901				MSG_CONTINUE,
2902				MSG_STOP,
2903				MSG_SHUTDOWN
2904				};
2905		protected:
2906			CWinApp* m_pMainApp;
2907			DWORD m_dwErr;
2908			SERVICE_STATUS m_ssStatus;
2909			SERVICE_STATUS_HANDLE m_sshStatusHandle;
2910			PSID m_pUserSID;				// the current user's security identifier
2911			DWORD m_dwTagID;
2912		public:
2913			CNTService(CWinApp* = NULL);
2914			virtual ~CNTService();
2915		protected:
2916			CNTService(const CNTService&);
2917			CNTService& operator=(const CNTService&);
2918			virtual DWORD GetControlsAccepted();
2919			virtual DWORD GetServiceCheckPoint();
2920			virtual DWORD GetDesiredAccess();
2921			virtual DWORD GetServiceType();
2922			virtual DWORD GetStartType();
2923			virtual DWORD GetErrorControl();
2924			virtual LPCTSTR GetLoadOrderGroup();
2925			virtual LPCTSTR GetDependencies();
2926			virtual LPCTSTR GetUserName();
2927			virtual LPCTSTR GetPassword();
2928			virtual LPCTSTR GetServiceName();
2929			virtual LPCTSTR GetDisplayName();
2930		public:
2931			virtual void Stop();
2932			virtual void Pause();
2933			virtual void Continue();
2934			virtual void Shutdown();
2935			virtual BOOL StartDispatcher();
2936			virtual BOOL InstallService();
2937			virtual BOOL RemoveService();
2938			virtual BOOL EndService();
2939			virtual BOOL StartupService();
2940			void StartServiceThread();
2941			virtual DWORD GetStopPendingTime();
2942			virtual DWORD GetPausePendingTime();
2943			virtual DWORD GetContinuePendingTime();
2944			virtual BOOL ProcessCommandLine();
2945			virtual BOOL ProcessCommandLine(LPCTSTR);
2946		protected:
2947			virtual void RegisterApplicationLog(LPCTSTR lpszProposedMessageFile,DWORD dwProposedTypes);
2948			virtual void DeregisterApplicationLog();
2949			static UINT ServiceThread(CNTService*);
2950		public:
2951			LPTSTR GetLastErrorText(LPTSTR Buf, DWORD Size);
2952			BOOL ReportStatus(DWORD CurState, DWORD WaitHint = 3000, DWORD ErrExit = 0);
2953			virtual void AddToMessageLog(LPCTSTR Message, WORD EventType = EVENTLOG_ERROR_TYPE, DWORD dwEventID = -1);
2954			static void WINAPI ServiceCtrl(DWORD CtrlCode);
2955			static void WINAPI ServiceMain(DWORD argc, LPTSTR* argv);
2956		};
2957	//--------------------------------------------------------------------------------
2958	inline void CNTService::StartServiceThread()
2959		{
2960		CWinThread* pThread = ::AfxBeginThread((AFX_THREADPROC) CNTService::ServiceThread, this);
2961		pThread->m_bAutoDelete = TRUE;
2962		::Sleep(1000);
2963		ReportStatus(SERVICE_RUNNING);
2964		}
2965	#endif	// NTService_h
ZZHEYXXHEYFile: Parameter.cppYYHEY

2966	//--------------------------------------------------------------------------------
2967	//
2968	// Copyright (c) 1999 @COMPANY
2969	//
2970	// Programming by Rich Schonthal
2971	//
2972	//--------------------------------------------------------------------------------
2973	//--------------------------------------------------------------------------------
2974	#include "stdafx.h"
2975	#include "Parameter.h"
2976	//--------------------------------------------------------------------------------
2977	CParameter::CParameter(DWORD nId)
2978		{
2979		m_nId = nId;
2980		}
2981	//--------------------------------------------------------------------------------
2982	CParameter::~CParameter()
2983		{
2984		}
2985	//--------------------------------------------------------------------------------
2986	DWORD CParameter::GetId() const
2987		{
2988		return m_nId;
2989		}
2990	//--------------------------------------------------------------------------------
2991	void CParameter::SetId(DWORD nId)
2992		{
2993		m_nId = nId;
2994		}
ZZHEYXXHEYFile: Parameter.hYYHEY

2995	//--------------------------------------------------------------------------------
2996	//
2997	// Copyright (c) 1999 @COMPANY
2998	//
2999	// Programming by Rich Schonthal
3000	//
3001	//--------------------------------------------------------------------------------
3002	//--------------------------------------------------------------------------------
3003	#if !defined(AFX_PARAMETER_H__5019D40A_84B9_11D3_B0D4_00A0CC271D0D__INCLUDED_)
3004	#define AFX_PARAMETER_H__5019D40A_84B9_11D3_B0D4_00A0CC271D0D__INCLUDED_
3005	#if _MSC_VER > 1000
3006	#pragma once
3007	#endif // _MSC_VER > 1000
3008	//--------------------------------------------------------------------------------
3009	#include "result.h"
3010	//--------------------------------------------------------------------------------
3011	class CParameter : public CResult
3012		{
3013		public:
3014			CParameter(DWORD = 0);
3015			virtual ~CParameter();
3016		protected:
3017			DWORD m_nId;
3018		public:
3019			DWORD GetId() const;
3020			void SetId(DWORD);
3021		virtual void* GetValue() = 0;
3022		virtual bool SetValue(void*) = 0;
3023		};
3024	#endif // !defined(AFX_PARAMETER_H__5019D40A_84B9_11D3_B0D4_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: RegChangeNotificationContextObj.cppYYHEY

3025	//--------------------------------------------------------------------------------
3026	// Copyright (c) 2001 @COMPANY
3027	// Created...: 6/8/01
3028	// Author....: Rich Schonthal
3029	//--------------------------------------------------------------------------------
3030	#include "stdafx.h"
3031	#include "ChangeNotificationContextObj.h"
3032	#include "ChangeNotificationObj.h"
3033	#include <SystemObject.h>
3034	#ifdef _DEBUG
3035	#undef THIS_FILE
3036	static char THIS_FILE[]=__FILE__;
3037	#define new DEBUG_NEW
3038	#endif
3039	//--------------------------------------------------------------------------------
3040	CRegChangeNotificationContextObj::CRegChangeNotificationContextObj()
3041			: m_hKey(NULL)
3042		{
3043		}
3044	//--------------------------------------------------------------------------------
3045	bool CRegChangeNotificationContextObj::Create(HKEY hKey, bool bWatchSubDir, DWORD nFilter, CSystemObject* pTarget, int nMsgId)
3046		{
3047		if(nFilter == 0xffffffff)
3048			nFilter = REG_NOTIFY_CHANGE_NAME|REG_NOTIFY_CHANGE_ATTRIBUTES|REG_NOTIFY_CHANGE_LAST_SET|REG_NOTIFY_CHANGE_SECURITY;
3049		m_hKey = hKey;
3050		m_nFilter = nFilter;
3051		m_pTarget = pTarget;
3052		m_nMessageId = nMsgId;
3053		m_bWatchSubDir = bWatchSubDir;
3054		m_event.ResetEvent();
3055		return GetNextChange();
3056		}
3057	//--------------------------------------------------------------------------------
3058	CRegChangeNotificationContextObj::~CRegChangeNotificationContextObj()
3059		{
3060		}
3061	//--------------------------------------------------------------------------------
3062	bool CRegChangeNotificationContextObj::PostChanges()
3063		{
3064		CRegChangeNotificationObj* pInfo = new CRegChangeNotificationObj(m_hKey);
3065		m_pTarget->PostMessage(GetMessageId(), (WPARAM) pInfo);
3066		return true;
3067		}
ZZHEYXXHEYFile: SocketServerMainThread.cppYYHEY

3068	//--------------------------------------------------------------------------------
3069	// Copyright (c) 2001 @COMPANY
3070	// Created...: 6/27/01
3071	// Author....: Rich Schonthal
3072	//--------------------------------------------------------------------------------
3073	#include "StdAfx.h"
3074	#include "SocketServerMainThread.h"
3075	#include "SocketServerSubSystem.h"
3076	//--------------------------------------------------------------------------------
3077	CSocketServerMainThread::CSocketServerMainThread(CSocketServerSubSystem* pParent)
3078			: CThreadObject(pParent)
3079			, m_pSub(pParent)
3080		{
3081		}
3082	//--------------------------------------------------------------------------------
3083	CSocketServerMainThread::~CSocketServerMainThread()
3084		{
3085		}
3086	//--------------------------------------------------------------------------------
3087	bool CSocketServerMainThread::MainLoop()
3088		{
3089		DWORD nState = GetState();
3090		if(nState == STATE_PAUSE)
3091			{
3092			if(m_pSub->IsClosePortsOnPause())
3093				m_socket.Close();
3094			return true;
3095			}
3096		if(m_socket.IsValid())
3097			{
3098			if(m_socket.Listen(5))
3099				{
3100				CSmallSocket sock;
3101				if(m_socket.Accept(sock))
3102					{
3103					SOCKET hSocket = sock.Detach();
3104					if(! m_pSub->PostNextThreadMessage(CSocketServerSubSystem::MsgConnect, (WPARAM) hSocket, 0))
3105						sock.Attach(hSocket);
3106					}
3107				}
3108			}
3109		return CheckState();
3110		}
3111	void CSocketServerMainThread::OnMessage(UINT, WPARAM, LPARAM)
3112		{
3113		}
ZZHEYXXHEYFile: SocketServerMainThread.hYYHEY

3114	//--------------------------------------------------------------------------------
3115	// Copyright (c) 2001 @COMPANY
3116	// Created...: 6/27/01
3117	// Author....: Rich Schonthal
3118	//--------------------------------------------------------------------------------
3119	#ifndef _SOCKETSERVERMAINTHREAD_H_
3120	#define _SOCKETSERVERMAINTHREAD_H_
3121	//--------------------------------------------------------------------------------
3122	#include "ThreadObject.h"
3123	#include <SmallSocket.h>
3124	//--------------------------------------------------------------------------------
3125	class CSocketServerSubSystem;
3126	//--------------------------------------------------------------------------------
3127	class CSocketServerMainThread : public CThreadObject
3128		{
3129		protected:
3130			CSmallSocket m_socket;
3131			CSocketServerSubSystem* m_pSub;
3132		public:
3133			CSocketServerMainThread(CSocketServerSubSystem*);
3134			virtual ~CSocketServerMainThread();
3135			virtual bool MainLoop();
3136			virtual void OnMessage(UINT, WPARAM, LPARAM);
3137		};
3138	#endif // _SOCKETSERVERMAINTHREAD_H_
ZZHEYXXHEYFile: SocketServerQueue.hYYHEY

3139	//--------------------------------------------------------------------------------
3140	// Copyright (c) 2001 @COMPANY
3141	// Created...: 6/30/01
3142	// Author....: Rich Schonthal
3143	//--------------------------------------------------------------------------------
3144	#ifndef _SOCKETSERVERQUEUE_H_
3145	#define _SOCKETSERVERQUEUE_H_
3146	//--------------------------------------------------------------------------------
3147	#include <StdobjQueue.h>
3148	//--------------------------------------------------------------------------------
3149	class CSocketServerQueueObj;
3150	//--------------------------------------------------------------------------------
3151	class CSocketServerQueue
3152		{
3153		public:
3154			// the queue names are relative to the client
3155			// data from the socket
3156			CSOQueue<CSocketServerQueueObj*, CSocketServerQueueObj*> m_qInput;
3157			// data to the socket
3158			CSOQueue<CSocketServerQueueObj*, CSocketServerQueueObj*> m_qOutput;
3159		};
3160	//--------------------------------------------------------------------------------
3161	class CSocketServerQueueObj
3162		{
3163		public:
3164			enum eMsgType
3165				{
3166				SSQO_NOOP				= 0x00000000,
3167				SSQO_ERROR				= 0x00000001,
3168				SSQO_CONNECTION_MADE	= 0x00000002,
3169				SSQO_DATA				= 0x00000004,
3170				SSQO_ABORT				= 0x00000008,
3171				SSQO_SOCKET_CLOSE		= 0x00000010
3172				};
3173		private:
3174			eMsgType m_nMsgType;
3175		protected:
3176			CSocketServerQueueObj(eMsgType);
3177			virtual ~CSocketServerQueueObj();
3178		public:
3179			eMsgType GetMsgType() const;
3180		};
3181	//--------------------------------------------------------------------------------
3182	inline CSocketServerQueueObj::CSocketServerQueueObj(eMsgType nMsgType)
3183			: m_nMsgType(nMsgType) {}
3184	//--------------------------------------------------------------------------------
3185	class CSocketServerQueueDataObj : public CSocketServerQueueObj
3186		{
3187		private:
3188			UCHAR* m_pData;
3189			int m_nLen;
3190		public:
3191			CSocketServerQueueDataObj(const void* pData, int nLen);
3192			virtual ~CSocketServerQueueDataObj();
3193			const void* GetData() const;
3194			int GetDataLength() const;
3195		};
3196	//--------------------------------------------------------------------------------
3197	inline CSocketServerQueueDataObj::CSocketServerQueueDataObj(const void* pData, int nLen)
3198			: CSocketServerQueueObj(SSQO_DATA)
3199			, m_nLen(nLen)
3200		{
3201		if(nLen == 0)
3202			m_pData = NULL;
3203		else
3204			{
3205			m_pData = new UCHAR[nLen];
3206			memcpy(m_pData, pData, nLen);
3207			}
3208		}
3209	//--------------------------------------------------------------------------------
3210	inline CSocketServerQueueDataObj::~CSocketServerQueueDataObj()
3211		{
3212		delete[] m_pData;
3213		}
3214	//--------------------------------------------------------------------------------
3215	inline const void* CSocketServerQueueDataObj::GetData() const { return m_pData; }
3216	inline int CSocketServerQueueDataObj::GetDataLength() const { return m_nLen; }
3217	#endif //_SOCKETSERVERQUEUE_H_
ZZHEYXXHEYFile: SocketServerSocketThread.cppYYHEY

3218	//--------------------------------------------------------------------------------
3219	// Copyright (c) 2001 @COMPANY
3220	// Created...: 6/30/01
3221	// Author....: Rich Schonthal
3222	//--------------------------------------------------------------------------------
3223	#include "StdAfx.h"
3224	#include "SocketServerSocketThread.h"
3225	#include "SocketServerSubSystem.h"
3226	//--------------------------------------------------------------------------------
3227	CSocketServerSocketThread::CSocketServerSocketThread(CSocketServerSubSystem* pParent)
3228			: CThreadObject(pParent)
3229			, m_pSub(pParent)
3230		{
3231		}
3232	//--------------------------------------------------------------------------------
3233	CSocketServerSocketThread::~CSocketServerSocketThread()
3234		{
3235		}
3236	//--------------------------------------------------------------------------------
3237	bool CSocketServerSocketThread::MainLoop()
3238		{
3239		DWORD nState = GetState();
3240		if(nState == STATE_PAUSE)
3241			{
3242			if(m_pSub->IsClosePortsOnPause())
3243				m_socket.Close();
3244			return true;
3245			}
3246		if(m_socket.IsValid())
3247			{
3248			if(m_socket.Listen(5))
3249				{
3250				CSmallSocket sock;
3251				if(m_socket.Accept(sock))
3252					{
3253					SOCKET hSocket = sock.Detach();
3254					if(! m_pSub->PostNextThreadMessage(CSocketServerSubSystem::MsgConnect, (WPARAM) hSocket, 0))
3255						sock.Attach(hSocket);
3256					}
3257				}
3258			}
3259		return CheckState();
3260		}
3261	//--------------------------------------------------------------------------------
3262	void CSocketServerSocketThread::OnMessage(UINT nMsg, WPARAM wparam, LPARAM lparam)
3263		{
3264		switch(nMsg)
3265			{
3266			case CSocketServerSubSystem::MsgConnect:
3267				m_socket.Attach((SOCKET) wparam);
3268				break;
3269			}
3270		}
ZZHEYXXHEYFile: SocketServerSocketThread.hYYHEY

3271	//--------------------------------------------------------------------------------
3272	// Copyright (c) 2001 @COMPANY
3273	// Created...: 6/27/01
3274	// Author....: Rich Schonthal
3275	//--------------------------------------------------------------------------------
3276	#ifndef _SOCKETSERVERSOCKETTHREAD_H_
3277	#define _SOCKETSERVERSOCKETTHREAD_H_
3278	//--------------------------------------------------------------------------------
3279	#include "ThreadObject.h"
3280	#include "SocketServerQueue.h"
3281	#include <SmallSocket.h>
3282	//--------------------------------------------------------------------------------
3283	class CSocketServerSocketThread : public CThreadObject
3284		{
3285		protected:
3286			friend class CSocketServerSubSystem;
3287			CSmallSocket m_socket;
3288			CSocketServerSubSystem* m_pSub;
3289			CSocketServerQueue m_queue;
3290		public:
3291			CSocketServerSocketThread(CSocketServerSubSystem*);
3292			virtual ~CSocketServerSocketThread();
3293			virtual bool MainLoop();
3294			virtual void OnMessage(UINT, WPARAM, LPARAM);
3295		};
3296	#endif // _SOCKETSERVERSOCKETTHREAD_H_
ZZHEYXXHEYFile: SocketServerSubSystem.cppYYHEY

3297	//--------------------------------------------------------------------------------
3298	// Copyright (c) 2001 @COMPANY
3299	// Created...: 6/26/01
3300	// Author....: Rich Schonthal
3301	//--------------------------------------------------------------------------------
3302	//--------------------------------------------------------------------------------
3303	#include "StdAfx.h"
3304	#include "SocketServerSubSystem.h"
3305	#include "SocketServerMainThread.h"
3306	#include <ReadLock.h>
3307	#include <WriteLock.h>
3308	//--------------------------------------------------------------------------------
3309	//IMPLEMENT_DYNAMIC(CSocketServerSubSystem, CThreadPoolSubSystem)
3310	//--------------------------------------------------------------------------------
3311	CSocketServerSubSystem::CSocketServerSubSystem(CSystem* pParent)
3312			: CThreadPoolSubSystem(pParent)
3313			, m_nPort(0)
3314			, m_pIP(NULL)
3315			, m_nMaxThreads(0)
3316		{
3317		m_evtPaused.SetEvent();
3318		}
3319	//--------------------------------------------------------------------------------
3320	CSocketServerSubSystem::~CSocketServerSubSystem()
3321		{
3322		}
3323	//--------------------------------------------------------------------------------
3324	void CSocketServerSubSystem::SetMaxThread(int nMax)
3325		{
3326		}
3327	//--------------------------------------------------------------------------------
3328	bool CSocketServerSubSystem::IsClosePortsOnPause()
3329		{
3330		return false;
3331		}
3332	//--------------------------------------------------------------------------------
3333	void CSocketServerSubSystem::StartSubSystem()
3334		{
3335		if(m_pMainThread == NULL)
3336			{
3337			m_pMainThread = new CSocketServerMainThread(this);
3338			m_pMainThread->StartThread();
3339			}
3340		CSubSystem::StartSubSystem();
3341		}
3342	//--------------------------------------------------------------------------------
3343	void CSocketServerSubSystem::SetIP(LPCTSTR pIP)
3344		{
3345		CWriteLock lock(this);
3346		AllocString(m_pIP, pIP);
3347		}
3348	//--------------------------------------------------------------------------------
3349	void CSocketServerSubSystem::SetPort(int nPort)
3350		{
3351		CWriteLock lock(this);
3352		m_nPort = nPort;
3353		}
3354	//--------------------------------------------------------------------------------
3355	LPCTSTR CSocketServerSubSystem::GetIP() const
3356		{
3357		CReadLock lock(const_cast<CSocketServerSubSystem*>(this));
3358		return m_pIP;
3359		}
3360	//--------------------------------------------------------------------------------
3361	int CSocketServerSubSystem::GetPort() const
3362		{
3363		CReadLock lock(const_cast<CSocketServerSubSystem*>(this));
3364		return m_nPort;
3365		}
3366	//--------------------------------------------------------------------------------
3367	int CSocketServerSubSystem::GetMaxThreads() const
3368		{
3369		CReadLock lock(const_cast<CSocketServerSubSystem*>(this));
3370		return m_nMaxThreads;
3371		}
ZZHEYXXHEYFile: SocketServerSubSystem.hYYHEY

3372	//--------------------------------------------------------------------------------
3373	// Copyright (c) 2001 @COMPANY
3374	// Created...: 6/26/01
3375	// Author....: Rich Schonthal
3376	//--------------------------------------------------------------------------------
3377	#ifndef _SOCKETSERVERSUBSYSTEM_H_
3378	#define _SOCKETSERVERSUBSYSTEM_H_
3379	//--------------------------------------------------------------------------------
3380	#include "SubSystem.h"
3381	#include "SocketServerQueue.h"
3382	#include <AllocString.h>
3383	#include <StdobjQueue.h>
3384	//--------------------------------------------------------------------------------
3385	class CSocketServerMainThread;
3386	class CSocketServerQueueId;
3387	//--------------------------------------------------------------------------------
3388	class CSocketServerSubSystem : public CThreadPoolSubSystem
3389		{
3390		public:
3391			// msgs sent only within the subsytem and worker threads
3392			// for msgs sent to target subsystems, see below
3393			enum
3394				{
3395				MsgConnect = WM_USER,
3396				};
3397		protected:
3398	//		DECLARE_DYNAMIC(CSocketServerSubSystem);
3399			long m_nPort;
3400			LPTSTR m_pIP;
3401			int m_nMaxThreads;
3402			CSocketServerMainThread* m_pMainThread;
3403			// maps the queue id to the thread that owns the queue
3404			CMapWordToPtr m_mapQueueId;
3405		public:
3406			CSocketServerSubSystem(CSystem*);
3407			virtual ~CSocketServerSubSystem();
3408			LPCTSTR GetIP() const;
3409			void SetIP(LPCTSTR);
3410			int GetPort() const;
3411			void SetPort(int);
3412			int GetMaxThreads() const;
3413			void SetMaxThread(int);
3414			virtual void StartSubSystem();
3415			// override this to close ports when the sub system is paused
3416			// (the default returns false)
3417			virtual bool IsClosePortsOnPause();
3418			CSocketServerQueueId* FindQueue(int nId);
3419			bool WriteQueue(CSocketServerQueueId*&, const CSocketServerQueueObj*);
3420			bool ReadQueue(CSocketServerQueueId*&, CSocketServerQueueObj*&);
3421		protected:
3422			friend class CSocketServerMainThread;
3423			friend class CSocketServerSocketThread;
3424			void RegisterQueue(int, CThreadObject*);
3425			void UnregisterQueue(CThreadObject*);
3426		};
3427	//--------------------------------------------------------------------------------
3428	class CSocketServerQueueId
3429		{
3430		protected:
3431			friend class CSocketServerSubSystem;
3432			int m_nId;
3433			CThreadObject* m_pThread;
3434			POSITION m_position;
3435		};
3436	#endif // _SOCKETSERVERSUBSYSTEM_H_
ZZHEYXXHEYFile: StateObject.cppYYHEY

3437	//--------------------------------------------------------------------------------
3438	//
3439	// Copyright (c) 1999 @COMPANY
3440	//
3441	// Programming by Rich Schonthal
3442	//
3443	//--------------------------------------------------------------------------------
3444	#include "stdafx.h"
3445	#include "StateObject.h"
3446	#include "SystemObject.h"
3447	#include <ReadLock.h>
3448	#include <WriteLock.h>
3449	//--------------------------------------------------------------------------------
3450	#include "waitlen.h"
3451	//--------------------------------------------------------------------------------
3452	CStateObject::CStateObject(int nValue)
3453			: m_nClients(0)
3454			, m_nClientsInSync(0)
3455			, m_nValue(nValue)
3456			, m_evtClientSync(false, true)
3457			, m_evtChanged(false, true)
3458		{
3459		}
3460	//--------------------------------------------------------------------------------
3461	CStateObject::~CStateObject()
3462		{
3463		}
3464	//--------------------------------------------------------------------------------
3465	bool CStateObject::SetValue(int nValue)
3466		{
3467		int nPrev = ::InterlockedExchange(&m_nValue, nValue);
3468		if(nPrev != m_nValue)
3469			{
3470			m_evtClientSync.ResetEvent();
3471			m_evtChanged.SetEvent();
3472			}
3473		return true;
3474		}
3475	//--------------------------------------------------------------------------------
3476	int CStateObject::GetValue()
3477		{
3478		return (int) m_nValue;
3479		}
3480	//--------------------------------------------------------------------------------
3481	void CStateObject::AddClient()
3482		{
3483		::InterlockedIncrement(&m_nClients);
3484		}
3485	//--------------------------------------------------------------------------------
3486	void CStateObject::RemoveClient()
3487		{
3488		::InterlockedDecrement(&m_nClients);
3489		}
3490	//--------------------------------------------------------------------------------
3491	void CStateObject::AcknowledgeChange()
3492		{
3493		if(m_nClients == 0)
3494			return;
3495		if(::InterlockedIncrement(&m_nClientsInSync) >= m_nClients)
3496			{
3497			m_nClientsInSync = 0;
3498			m_evtClientSync.SetEvent();
3499			m_evtChanged.ResetEvent();
3500			}
3501		}
3502	#ifdef _DEBUG
3503	//--------------------------------------------------------------------------------
3504	static struct tagStateNames
3505		{
3506		int nState;
3507		LPCTSTR pName;
3508		} g_stateNames[] =
3509		{
3510		STATE_UNKNOWN, _T("STATE_UNKNOWN"),
3511		STATE_INIT, _T("STATE_INIT"),
3512		STATE_RUN, _T("STATE_RUN"),
3513		STATE_PAUSE, _T("STATE_PAUSE"),
3514		STATE_STOP, _T("STATE_STOP"),
3515		STATE_EXIT, _T("STATE_EXIT"),
3516		STATE_ERROR, _T("STATE_ERROR"),
3517		STATE_NOSTATE, _T("STATE_NOSTATE"),
3518		STATE_UNATTAINED, _T("STATE_UNATTAINED"),
3519		0, NULL
3520		};
3521	//--------------------------------------------------------------------------------
3522	LPCTSTR CStateObject::GetStateName(int nState) const
3523		{
3524		LPCTSTR sTemp = _T("");
3525		for(int i = 0; ; i++)
3526			{
3527			if(g_stateNames[i].pName == NULL)
3528				break;
3529			if(g_stateNames[i].nState == nState)
3530				{
3531				sTemp = g_stateNames[i].pName;
3532				break;
3533				}
3534			}
3535		return sTemp;
3536		}
3537	#endif
ZZHEYXXHEYFile: StateObject.hYYHEY

3538	//--------------------------------------------------------------------------------
3539	//
3540	// Copyright (c) 1999 @COMPANY
3541	//
3542	// Programming by Rich Schonthal
3543	//
3544	//--------------------------------------------------------------------------------
3545	//--------------------------------------------------------------------------------
3546	#if !defined(AFX_StateObject_H__42D4F267_830D_11D3_AEFF_005004A1C5F3__INCLUDED_)
3547	#define AFX_StateObject_H__42D4F267_830D_11D3_AEFF_005004A1C5F3__INCLUDED_
3548	#if _MSC_VER > 1000
3549	#pragma once
3550	#endif // _MSC_VER > 1000
3551	//--------------------------------------------------------------------------------
3552	#include "result.h"
3553	#include "ReadWriteObject.h"
3554	//--------------------------------------------------------------------------------
3555	enum
3556		{
3557		STATE_UNKNOWN = 0,
3558		// standard states
3559		STATE_LOWEST = 1,
3560		STATE_INIT = STATE_LOWEST,
3561		STATE_RUN,
3562		STATE_PAUSE,
3563		STATE_STOP,
3564		STATE_EXIT,
3565		STATE_ERROR,
3566		HIGHEST_STANDARD_STATE = STATE_ERROR,
3567		// error condition states
3568		STATE_NOSTATE = -1,
3569		STATE_UNATTAINED = -2
3570		};
3571	//--------------------------------------------------------------------------------
3572	class CStateObject : public CResult, public CReadWriteObject
3573		{
3574		public:
3575			CStateObject(int = STATE_UNKNOWN);
3576			virtual ~CStateObject();
3577			CMutex m_mutex;
3578			CEvent m_evtChanged;
3579			// the # of threads responding to state changes
3580			long m_nClients;
3581			// the # of threads that have acknowledged the last state change
3582			long m_nClientsInSync;
3583			// event signaled when state sync is reached (ie m_nStateClients == m_nStateInSync)
3584			CEvent m_evtClientSync;
3585		private:
3586			// the state value
3587			long m_nValue;
3588		public:
3589			bool SetValue(int);
3590			int GetValue();
3591			void AddClient();
3592			void RemoveClient();
3593			void AcknowledgeChange();
3594	#ifdef _DEBUG
3595			LPCTSTR GetStateName(int) const;
3596	#endif
3597		};
3598	#endif // !defined(AFX_StateObject_H__42D4F267_830D_11D3_AEFF_005004A1C5F3__INCLUDED_)
ZZHEYXXHEYFile: StdAfx.cppYYHEY

3599	// stdafx.cpp : source file that includes just the standard includes
3600	//	ServerLib.pch will be the pre-compiled header
3601	//	stdafx.obj will contain the pre-compiled type information
3602	#include "stdafx.h"
ZZHEYXXHEYFile: StdAfx.hYYHEY

3603	//--------------------------------------------------------------------------------
3604	//
3605	// Copyright (c) 1999 @COMPANY
3606	//
3607	// Programming by Rich Schonthal
3608	//
3609	//--------------------------------------------------------------------------------
3610	// stdafx.h : include file for standard system include files,
3611	//  or project specific include files that are used frequently, but
3612	//      are changed infrequently
3613	//
3614	#if !defined(AFX_STDAFX_H__42D4F253_830D_11D3_AEFF_005004A1C5F3__INCLUDED_)
3615	#define AFX_STDAFX_H__42D4F253_830D_11D3_AEFF_005004A1C5F3__INCLUDED_
3616	#define  WINVER  0x0400
3617	#if _MSC_VER > 1000
3618	#pragma once
3619	#endif // _MSC_VER > 1000
3620	#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
3621	#define _AFX_NOFORCE_LIBS
3622	#include <afx.h>
3623	#include <afxwin.h>
3624	#include <afxmt.h>
3625	#include <afxtempl.h>
3626	#include <commondefines.h>
3627	#define ReleaseTimeslice() ::Sleep(0)
3628	// TODO: reference additional headers your program requires here
3629	//{{AFX_INSERT_LOCATION}}
3630	// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
3631	#endif // !defined(AFX_STDAFX_H__42D4F253_830D_11D3_AEFF_005004A1C5F3__INCLUDED_)
ZZHEYXXHEYFile: SubSystem.cppYYHEY

3632	//--------------------------------------------------------------------------------
3633	//
3634	// Copyright (c) 1999 @COMPANY
3635	//
3636	// Programming by Rich Schonthal
3637	//
3638	//--------------------------------------------------------------------------------
3639	//--------------------------------------------------------------------------------
3640	#include "stdafx.h"
3641	#include "SubSystem.h"
3642	#include "ThreadObject.h"
3643	#include "System.h"
3644	//--------------------------------------------------------------------------------
3645	IMPLEMENT_DYNAMIC(CSubSystem, CSystemControlObject)
3646	//--------------------------------------------------------------------------------
3647	CSubSystem::CSubSystem(CSystem* pSys)
3648			: CSystemControlObject(pSys)
3649		{
3650		if(pSys != NULL)
3651			m_pState = pSys->m_pState;
3652		}
3653	//--------------------------------------------------------------------------------
3654	CSubSystem::~CSubSystem()
3655		{
3656		m_pState = NULL;
3657		}
3658	//--------------------------------------------------------------------------------
3659	CSystem* CSubSystem::GetSystem()
3660		{
3661		return (CSystem*) GetParent();
3662		}
3663	//--------------------------------------------------------------------------------
3664	bool CSubSystem::Init()
3665		{
3666		return true;
3667		}
ZZHEYXXHEYFile: SubSystem.hYYHEY

3668	//--------------------------------------------------------------------------------
3669	//
3670	// Copyright (c) 1999 @COMPANY
3671	//
3672	// Programming by Rich Schonthal
3673	//
3674	//--------------------------------------------------------------------------------
3675	//--------------------------------------------------------------------------------
3676	#if !defined(AFX_SUBSYSTEM_H__9F10BA2A_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_)
3677	#define AFX_SUBSYSTEM_H__9F10BA2A_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_
3678	#if _MSC_VER > 1000
3679	#pragma once
3680	#endif // _MSC_VER > 1000
3681	//--------------------------------------------------------------------------------
3682	#include "SystemControlObject.h"
3683	#include <StdobjQueue.h>
3684	//--------------------------------------------------------------------------------
3685	class CSystem;
3686	class CThreadObject;
3687	//--------------------------------------------------------------------------------
3688	class CSubSystem : public CSystemControlObject
3689		{
3690		protected:
3691			DECLARE_DYNAMIC(CSubSystem)
3692			friend class CThreadObject;
3693		protected:
3694			CEvent m_event;
3695		public:
3696			CSubSystem(CSystem*);
3697			virtual ~CSubSystem();
3698			// returns a ptr to the system this sub system is a part of
3699			CSystem* GetSystem();
3700			// called by CSystem
3701			virtual bool Init();
3702		};
3703	//--------------------------------------------------------------------------------
3704	class CThreadPoolSubSystem : public CSubSystem
3705		{
3706		DECLARE_DYNAMIC(CThreadPoolSubSystem)
3707		friend class CThreadObject;
3708		protected:
3709			CQueue<CThreadObject*, CThreadObject*> m_threads;
3710			LONG m_nBusyThreadCount;
3711			DWORD m_nProcessorCount;
3712		public:
3713			CThreadPoolSubSystem(CSystem*);
3714			virtual ~CThreadPoolSubSystem();
3715			// posts a message to all threads
3716			virtual bool PostMessage(UINT, WPARAM = 0, LPARAM = 0);
3717			// posts a message to the next thread in the pool
3718			virtual bool PostNextThreadMessage(UINT, WPARAM = 0, LPARAM = 0);
3719			// adds a thread to the thread pool
3720			// if count == -1, one thread is added for each processor in the system
3721			virtual bool AddThread(CRuntimeClass*, int nCount = -1);
3722			virtual void AddThread(CThreadObject*);
3723			LONG GetBusyThreadCount();
3724			bool WaitForAllToExit(DWORD = INFINITE);
3725			virtual CThreadObject* CreateThread(CRuntimeClass* = NULL);
3726		protected:
3727			void IncBusyThreadCount();
3728			void DecBusyThreadCount();
3729		};
3730	//--------------------------------------------------------------------------------
3731	template<class T_SYSTEM>
3732	class CTypedSubSystem : public CSubSystem
3733		{
3734		private:
3735			T_SYSTEM* m_pSystem;
3736		public:
3737			CTypedSubSystem(T_SYSTEM* = NULL);
3738			virtual ~CTypedSubSystem();
3739			T_SYSTEM* GetSystem();
3740		};
3741	//--------------------------------------------------------------------------------
3742	template<class T_SYSTEM>
3743	class CTypedThreadPoolSubSystem : public CThreadPoolSubSystem
3744		{
3745		private:
3746			T_SYSTEM* m_pSystem;
3747		public:
3748			CTypedThreadPoolSubSystem(T_SYSTEM* = NULL);
3749			virtual ~CTypedThreadPoolSubSystem();
3750			T_SYSTEM* GetSystem();
3751		};
3752	//--------------------------------------------------------------------------------
3753	template<class T_SYSTEM>
3754	inline CTypedSubSystem<T_SYSTEM>::CTypedSubSystem(T_SYSTEM* pSys)
3755		: CSubSystem((CSystem*) pSys), m_pSystem(pSys) {}
3756	template<class T_SYSTEM>
3757	inline CTypedSubSystem<T_SYSTEM>::~CTypedSubSystem() {}
3758	template<class T_SYSTEM>
3759	inline T_SYSTEM* CTypedSubSystem<T_SYSTEM>::GetSystem() { return m_pSystem; }
3760	//--------------------------------------------------------------------------------
3761	template<class T_SYSTEM>
3762	inline CTypedThreadPoolSubSystem<T_SYSTEM>::CTypedThreadPoolSubSystem(T_SYSTEM* pSys)
3763		: CThreadPoolSubSystem((CSystem*) pSys), m_pSystem(pSys) {}
3764	template<class T_SYSTEM>
3765	inline CTypedThreadPoolSubSystem<T_SYSTEM>::~CTypedThreadPoolSubSystem() {}
3766	template<class T_SYSTEM>
3767	inline T_SYSTEM* CTypedThreadPoolSubSystem<T_SYSTEM>::GetSystem() { return m_pSystem; }
3768	//--------------------------------------------------------------------------------
3769	inline LONG CThreadPoolSubSystem::GetBusyThreadCount() { return m_nBusyThreadCount; }
3770	inline void CThreadPoolSubSystem::IncBusyThreadCount() { ::InterlockedIncrement(&m_nBusyThreadCount); }
3771	inline void CThreadPoolSubSystem::DecBusyThreadCount() { ::InterlockedDecrement(&m_nBusyThreadCount); }
3772	#endif // !defined(AFX_SUBSYSTEM_H__9F10BA2A_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: SubSystemControlThread.cppYYHEY

3773	//--------------------------------------------------------------------------------
3774	//
3775	// Copyright (c) 1999 @COMPANY
3776	//
3777	// Programming by Rich Schonthal
3778	//
3779	//--------------------------------------------------------------------------------
3780	// purpose:
3781	// to syncronize the state of the parent subsystem with the controlling system
3782	//--------------------------------------------------------------------------------
3783	#include "stdafx.h"
3784	#include "SubSystemControlThread.h"
3785	//--------------------------------------------------------------------------------
3786	CSubSystemControlThread::CSubSystemControlThread(CSubSystem* pParent)
3787			: CThreadObject(pParent->GetParent())
3788		{
3789		ASSERT(pParent != NULL);
3790		m_pSubSystem = pParent;
3791		ASSERT(m_pSubSystem->GetRuntimeClass() == RUNTIME_CLASS(CSubSystem));
3792		m_nLastState = 0xffffffff;
3793		m_bRunning = true;
3794		}
3795	//--------------------------------------------------------------------------------
3796	CSubSystemControlThread::~CSubSystemControlThread()
3797		{
3798		}
3799	//--------------------------------------------------------------------------------
3800	bool CSubSystemControlThread::MainLoop()
3801		{
3802		return m_bRunning;
3803		}
3804	//--------------------------------------------------------------------------------
3805	void CSubSystemControlThread::OnStateChange(DWORD nState)
3806		{
3807		GetSystem()->AcknowledgeStateChange();
3808		m_bRunning = CheckState();
3809		}
ZZHEYXXHEYFile: SubSystemControlThread.hYYHEY

3810	//--------------------------------------------------------------------------------
3811	//
3812	// Copyright (c) 1999 @COMPANY
3813	//
3814	// Programming by Rich Schonthal
3815	//
3816	//--------------------------------------------------------------------------------
3817	//--------------------------------------------------------------------------------
3818	#if !defined(AFX_SUBSYSTEMCONTROLTHREAD_H__785892DD_8B64_11D3_B0DD_00A0CC271D0D__INCLUDED_)
3819	#define AFX_SUBSYSTEMCONTROLTHREAD_H__785892DD_8B64_11D3_B0DD_00A0CC271D0D__INCLUDED_
3820	#if _MSC_VER > 1000
3821	#pragma once
3822	#endif // _MSC_VER > 1000
3823	//--------------------------------------------------------------------------------
3824	#include "ThreadObject.h"
3825	#include "System.h"
3826	//--------------------------------------------------------------------------------
3827	class CSubSystemControlThread : public CThreadObject
3828		{
3829		protected:
3830			CSubSystem* m_pSubSystem;
3831			DWORD m_nLastState;
3832			bool m_bRunning;
3833		public:
3834			CSubSystemControlThread(CSubSystem*);
3835			virtual ~CSubSystemControlThread();
3836			virtual void OnStateChange(DWORD);
3837			virtual bool MainLoop();
3838			CSystem* GetSystem()		{ return (CSystem*) GetParent(); }
3839			CSubSystem* GetSubSystem()	{ return m_pSubSystem; }
3840		};
3841	#endif // !defined(AFX_SUBSYSTEMCONTROLTHREAD_H__785892DD_8B64_11D3_B0DD_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: System.cppYYHEY

3842	//--------------------------------------------------------------------------------
3843	//
3844	// Copyright (c) 1999 @COMPANY
3845	//
3846	// Programming by Rich Schonthal
3847	//
3848	//--------------------------------------------------------------------------------
3849	//--------------------------------------------------------------------------------
3850	#include "stdafx.h"
3851	#include "System.h"
3852	#include "SubSystem.h"
3853	//--------------------------------------------------------------------------------
3854	IMPLEMENT_DYNAMIC(CSystem, CSystemControlObject)
3855	//--------------------------------------------------------------------------------
3856	CSystem::CSystem(CSystemControlObject* pParent)
3857			: CSystemControlObject(pParent)
3858		{
3859		m_pState = new CSystemState;
3860		}
3861	//--------------------------------------------------------------------------------
3862	CSystem::~CSystem()
3863		{
3864		}
3865	#ifdef _DEBUG
3866	//--------------------------------------------------------------------------------
3867	bool CSystem::PostMessage(UINT nMsg, WPARAM wParam, LPARAM lParam)
3868		{
3869		POSITION pos = m_subSystemList.GetHeadPosition();
3870		bool bRv = pos != NULL;
3871		for(; pos != NULL; )
3872			{
3873			CSubSystem* pSub = static_cast<CSubSystem*>(m_subSystemList.GetNext(pos));
3874			if(! pSub->PostMessage(nMsg, wParam, lParam))
3875				bRv = false;
3876			}
3877		return bRv;
3878		}
3879	#else
3880	//--------------------------------------------------------------------------------
3881	bool CSystem::PostMessage(UINT nMsg, WPARAM wParam, LPARAM lParam)
3882		{
3883		for(POSITION pos = m_subSystemList.GetHeadPosition(); pos != NULL; )
3884			{
3885			if(! m_subSystemList.GetNext(pos)->PostMessage(nMsg, wParam, lParam))
3886				return false;
3887			}
3888		return true;
3889		}
3890	#endif
3891	//--------------------------------------------------------------------------------
3892	bool CSystem::AddSubSystem(CSubSystem* pSub)
3893		{
3894		CRuntimeClass* pClass = pSub->GetRuntimeClass();
3895		if(pClass == NULL)
3896			return false;
3897		if(! pClass->IsDerivedFrom(RUNTIME_CLASS(CSubSystem)))
3898			return false;
3899		if(! pSub->Init())
3900			return false;
3901		return m_subSystemList.AddTail(pSub) != NULL;
3902		}
3903	//--------------------------------------------------------------------------------
3904	CSubSystem* CSystem::FindSubSystem(int nId)
3905		{
3906		for(POSITION pos = m_subSystemList.GetHeadPosition(); pos != NULL; )
3907			{
3908			CSubSystem* pSub = (CSubSystem*) m_subSystemList.GetNext(pos);
3909			if(pSub->GetObjectId() == nId)
3910				return pSub;
3911			}
3912		return NULL;
3913		}
3914	//--------------------------------------------------------------------------------
3915	bool CSystem::DeleteSubSystems()
3916		{
3917		TRY
3918			{
3919			for(POSITION pos = m_subSystemList.GetHeadPosition(); pos != NULL; )
3920				delete (CSubSystem*) m_subSystemList.GetNext(pos);
3921			m_subSystemList.RemoveAll();
3922			}
3923		CATCH_ALL(e)
3924			{
3925			return false;
3926			}
3927		END_CATCH_ALL;
3928		return true;
3929		}
ZZHEYXXHEYFile: System.hYYHEY

3930	//--------------------------------------------------------------------------------
3931	//
3932	// Copyright (c) 1999 @COMPANY
3933	//
3934	// Programming by Rich Schonthal
3935	//
3936	//--------------------------------------------------------------------------------
3937	//--------------------------------------------------------------------------------
3938	#if !defined(AFX_SYSTEM_H__9F10BA2C_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_)
3939	#define AFX_SYSTEM_H__9F10BA2C_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_
3940	#if _MSC_VER > 1000
3941	#pragma once
3942	#endif // _MSC_VER > 1000
3943	//--------------------------------------------------------------------------------
3944	#include "SystemControlObject.h"
3945	#include "SubSystem.h"
3946	//--------------------------------------------------------------------------------
3947	typedef CStateObject CSystemState;
3948	//--------------------------------------------------------------------------------
3949	class CSubSystem;
3950	class CSystemConfig;
3951	//--------------------------------------------------------------------------------
3952	class CSystem : public CSystemControlObject
3953		{
3954		friend class CSubSystem;
3955		DECLARE_DYNAMIC(CSystem)
3956		public:
3957			CSystem(CSystemControlObject* = NULL);
3958			virtual ~CSystem();
3959			enum
3960				{
3961				MSG_QUIT = WM_QUIT,
3962				MSG_INIT = WM_USER,
3963				MSG_RELOAD,
3964				MSG_CONFIG_CHANGED,
3965				MSG_STATE_CHANGED,
3966				// use MSG_DERIVED_START as the 1st msg num in derived classes
3967				MSG_DERIVED_START = WM_USER + 200
3968				};
3969		protected:
3970			// the subsystem list - a system can have any number of subsystems
3971			CList<CSystemControlObject*, CSystemControlObject*> m_subSystemList;
3972			bool DeleteSubSystems();
3973		public:
3974			// adds a sub system to the sub system list
3975			bool AddSubSystem(CSubSystem*);
3976			// posts a message to all sub-systems
3977			virtual bool PostMessage(UINT, WPARAM = 0, LPARAM = 0);
3978			CSubSystem* FindSubSystem(int nId);
3979		};
3980	//--------------------------------------------------------------------------------
3981	#define SUBSYSTEMID_IO			OIDTM_SUBSYSTEM + SLOID_IO
3982	#define SUBSYSTEMID_DB			OIDTM_SUBSYSTEM + SLOID_DB
3983	#define SUBSYSTEMID_FTP			OIDTM_SUBSYSTEM + SLOID_FTP
3984	#endif // !defined(AFX_SYSTEM_H__9F10BA2C_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: SystemConfig.cppYYHEY

3985	//--------------------------------------------------------------------------------
3986	//
3987	// Copyright (c) 1999 @COMPANY
3988	//
3989	// Programming by Rich Schonthal
3990	//
3991	//--------------------------------------------------------------------------------
3992	//--------------------------------------------------------------------------------
3993	#include "stdafx.h"
3994	#include "SystemConfig.h"
3995	//--------------------------------------------------------------------------------
3996	CSystemConfig::CSystemConfig(CSystemControlObject* pParent)
3997			: CSystemObject((CSystemObject*) pParent)
3998		{
3999		}
4000	//--------------------------------------------------------------------------------
4001	CSystemConfig::~CSystemConfig()
4002		{
4003		}
4004	//--------------------------------------------------------------------------------
4005	bool CSystemConfig::Read()
4006		{
4007		return false;
4008		}
4009	//--------------------------------------------------------------------------------
4010	bool CSystemConfig::Reload()
4011		{
4012		return Read();
4013		}
4014	//--------------------------------------------------------------------------------
4015	bool CSystemConfig::Write()
4016		{
4017		return false;
4018		}
4019	//--------------------------------------------------------------------------------
4020	bool CSystemConfig::IsDirty()
4021		{
4022		return false;
4023		}
ZZHEYXXHEYFile: SystemConfig.hYYHEY

4024	//--------------------------------------------------------------------------------
4025	//
4026	// Copyright (c) 1999 @COMPANY
4027	//
4028	// Programming by Rich Schonthal
4029	//
4030	//--------------------------------------------------------------------------------
4031	//--------------------------------------------------------------------------------
4032	#if !defined(AFX_SYSTEMCONFIG_H__42D4F266_830D_11D3_AEFF_005004A1C5F3__INCLUDED_)
4033	#define AFX_SYSTEMCONFIG_H__42D4F266_830D_11D3_AEFF_005004A1C5F3__INCLUDED_
4034	#if _MSC_VER > 1000
4035	#pragma once
4036	#endif // _MSC_VER > 1000
4037	//--------------------------------------------------------------------------------
4038	class CSystem;
4039	//--------------------------------------------------------------------------------
4040	#include "SystemObject.h"
4041	//--------------------------------------------------------------------------------
4042	class CSystemConfig : public CSystemObject
4043		{
4044		public:
4045			CSystemConfig(CSystemControlObject*);
4046			virtual ~CSystemConfig();
4047		public:
4048			virtual bool Read();
4049			virtual bool Reload();
4050			virtual bool Write();
4051			virtual bool IsDirty();
4052		};
4053	#endif // !defined(AFX_SYSTEMCONFIG_H__42D4F266_830D_11D3_AEFF_005004A1C5F3__INCLUDED_)
ZZHEYXXHEYFile: SystemControlObject.cppYYHEY

4054	//--------------------------------------------------------------------------------
4055	//
4056	// Copyright (c) 1999 @COMPANY
4057	//
4058	// Programming by Rich Schonthal
4059	//
4060	//--------------------------------------------------------------------------------
4061	//--------------------------------------------------------------------------------
4062	#include "stdafx.h"
4063	#include "StateObject.h"
4064	#include "SystemControlObject.h"
4065	//--------------------------------------------------------------------------------
4066	IMPLEMENT_DYNAMIC(CSystemControlObject, CSystemObject)
4067	//--------------------------------------------------------------------------------
4068	CSystemControlObject::CSystemControlObject(CSystemObject* pParent)
4069			: CSystemObject(pParent)
4070		{
4071		}
4072	//--------------------------------------------------------------------------------
4073	CSystemControlObject::~CSystemControlObject()
4074		{
4075		}
4076	//--------------------------------------------------------------------------------
4077	bool CSystemControlObject::SetState(DWORD nState)
4078		{
4079		if(m_pState == NULL)
4080			return false;
4081		return m_pState->SetValue(nState);
4082		}
4083	//--------------------------------------------------------------------------------
4084	bool CSystemControlObject::WaitForStateSync(DWORD nWait)
4085		{
4086		if(m_pState == NULL)
4087			return false;
4088		if(m_pState->m_nClients == 0)
4089			return true;
4090		return ::WaitForSingleObject(m_pState->m_evtClientSync, nWait) == WAIT_OBJECT_0;
4091		}
4092	//--------------------------------------------------------------------------------
4093	void CSystemControlObject::OnStateSync()
4094		{
4095		}
4096	/*
4097	//--------------------------------------------------------------------------------
4098	extern void AFXAPI DestructElements<CSystemControlObject*>(CSystemControlObject** pElements, int nCount)
4099		{
4100		while(--nCount >= 0)
4101			delete pElements[nCount];
4102		}
4103	*/
ZZHEYXXHEYFile: SystemControlObject.hYYHEY

4104	//--------------------------------------------------------------------------------
4105	//
4106	// Copyright (c) 1999 @COMPANY
4107	//
4108	// Programming by Rich Schonthal
4109	//
4110	//--------------------------------------------------------------------------------
4111	//--------------------------------------------------------------------------------
4112	#if !defined(AFX_SYSTEMCONTROLOBJECT_H__E88D4A3F_869D_11D3_B0D4_00A0CC271D0D__INCLUDED_)
4113	#define AFX_SYSTEMCONTROLOBJECT_H__E88D4A3F_869D_11D3_B0D4_00A0CC271D0D__INCLUDED_
4114	#if _MSC_VER > 1000
4115	#pragma once
4116	#endif // _MSC_VER > 1000
4117	//--------------------------------------------------------------------------------
4118	#include "SystemObject.h"
4119	//--------------------------------------------------------------------------------
4120	class CSystemControlObject : public CSystemObject
4121		{
4122		DECLARE_DYNAMIC(CSystemControlObject)
4123		public:
4124			CSystemControlObject(CSystemObject* pParent);
4125			virtual ~CSystemControlObject();
4126		public:
4127			// state
4128			//--------------------------------------------------------------------------------
4129			// set the state of this object
4130			virtual bool SetState(DWORD);
4131			// waits until all state clients have signaled
4132			virtual bool WaitForStateSync(DWORD = INFINITE);
4133			// called when all state clients reach sync
4134			virtual void OnStateSync();
4135		};
4136	/*
4137	//--------------------------------------------------------------------------------
4138	extern void AFXAPI DestructElements(CSystemControlObject** pElements, int nCount);
4139	*/
4140	#endif // !defined(AFX_SYSTEMCONTROLOBJECT_H__E88D4A3F_869D_11D3_B0D4_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: SystemObject.cppYYHEY

4141	//--------------------------------------------------------------------------------
4142	//
4143	// Copyright (c) 1999 @COMPANY
4144	//
4145	// Programming by Rich Schonthal
4146	//
4147	//--------------------------------------------------------------------------------
4148	//--------------------------------------------------------------------------------
4149	#include "stdafx.h"
4150	#include "SystemObject.h"
4151	#ifdef _DEBUG
4152	#include "IOThread.h"
4153	#endif
4154	//--------------------------------------------------------------------------------
4155	IMPLEMENT_DYNAMIC(CSystemObject, CObject);
4156	//--------------------------------------------------------------------------------
4157	CSystemObject::CSystemObject(CSystemObject* pParent)
4158			: m_pParent(pParent)
4159			, m_pState(NULL)
4160		{
4161		}
4162	//--------------------------------------------------------------------------------
4163	CSystemObject::~CSystemObject()
4164		{
4165		delete m_pState;
4166		}
4167	//--------------------------------------------------------------------------------
4168	bool CSystemObject::PostMessage(UINT, WPARAM, LPARAM)
4169		{
4170		return false;
4171		}
4172	//--------------------------------------------------------------------------------
4173	CSystemObject* CSystemObject::GetParent()
4174		{
4175		return m_pParent;
4176		}
4177	//--------------------------------------------------------------------------------
4178	DWORD CSystemObject::GetState()
4179		{
4180		if(m_pParent == NULL && m_pState == NULL)
4181			return STATE_RUN;
4182		if(m_pState == NULL)
4183			return STATE_UNKNOWN;
4184		return m_pState->GetValue();
4185		}
4186	//--------------------------------------------------------------------------------
4187	CStateObject* CSystemObject::GetStatePtr()
4188		{
4189		return m_pState;
4190		}
4191	//--------------------------------------------------------------------------------
4192	void CSystemObject::AddStateClient()
4193		{
4194		if(m_pState != NULL)
4195			m_pState->AddClient();
4196		}
4197	//--------------------------------------------------------------------------------
4198	void CSystemObject::RemoveStateClient()
4199		{
4200		if(m_pState != NULL)
4201			m_pState->RemoveClient();
4202		}
4203	//--------------------------------------------------------------------------------
4204	void CSystemObject::AcknowledgeStateChange()
4205		{
4206		if(m_pState != NULL)
4207			m_pState->AcknowledgeChange();
4208		}
4209	//--------------------------------------------------------------------------------
4210	int CSystemObject::GetObjectId()
4211		{
4212		return -1;
4213		}
4214	/*
4215	//--------------------------------------------------------------------------------
4216	extern void AFXAPI DestructElements<CSystemObject*>(CSystemObject** pElements, int nCount)
4217		{
4218		while(--nCount >= 0)
4219			delete pElements[nCount];
4220		}
4221	*/
ZZHEYXXHEYFile: SystemObject.hYYHEY

4222	//--------------------------------------------------------------------------------
4223	//
4224	// Copyright (c) 1999 @COMPANY
4225	//
4226	// Programming by Rich Schonthal
4227	//
4228	//--------------------------------------------------------------------------------
4229	//--------------------------------------------------------------------------------
4230	#if !defined(AFX_SYSTEMOBJECT_H__9F10BA26_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_)
4231	#define AFX_SYSTEMOBJECT_H__9F10BA26_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_
4232	#if _MSC_VER > 1000
4233	#pragma once
4234	#endif // _MSC_VER > 1000
4235	//--------------------------------------------------------------------------------
4236	#include "result.h"
4237	#include "StateObject.h"
4238	#include <LockedList.h>
4239	//--------------------------------------------------------------------------------
4240	enum
4241		{
4242		SO_DEFAULT_PULSE_INTERVAL = 2000,
4243		// error codes
4244		SO_NULL_PARENT = -1
4245		};
4246	//--------------------------------------------------------------------------------
4247	class CSystemConfig;
4248	class CSystemControlObject;
4249	//--------------------------------------------------------------------------------
4250	class CSystemObject : public CObject, public CResult
4251		{
4252		friend class CThreadObject;
4253		friend class CSubSystemBase;
4254		DECLARE_DYNAMIC(CSystemObject);
4255		public:
4256			// general purpose object lock
4257			CMutex m_mutex;
4258			// general purpose signal
4259			CEvent m_event;
4260			// signaled when this system object
4261			// throws an exception
4262			CEvent m_evtException;
4263		public:
4264			CSystemObject(CSystemObject* pParent);
4265			virtual ~CSystemObject();
4266		// attributes
4267		protected:
4268			// the parent of this object or null if this is a root object
4269			CSystemObject* m_pParent;
4270			// the state - a non systemcontrol object will be given a local state
4271			// by a systemcontrol object
4272			CStateObject* m_pState;
4273		public:
4274			// returns the parent of this object or null if this is a root object
4275			CSystemObject* GetParent();
4276			// state
4277			//--------------------------------------------------------------------------------
4278			// returns the state of the controlling parent
4279			virtual DWORD GetState();
4280			virtual CStateObject* GetStatePtr();
4281			virtual void AddStateClient();
4282			virtual void RemoveStateClient();
4283			virtual void AcknowledgeStateChange();
4284			// messaging
4285			//--------------------------------------------------------------------------------
4286			virtual bool PostMessage(UINT, WPARAM = 0, LPARAM = 0);
4287			// object id type masks
4288			enum
4289				{
4290				OIDTM_THREAD =    0x10000000,
4291				OIDTM_SUBSYSTEM = 0x20000000,
4292				OIDTM_SYSTEM =    0x40000000
4293				};
4294			// serverlib object ids
4295			enum
4296				{
4297				SLOID_IO	= 0x00010000,
4298				SLOID_DB	= 0x00020000,
4299				SLOID_CN	= 0x00040000,
4300				SLOID_FTP	= 0x00080000
4301				};
4302			// ID format:
4303			// bit 31 - default (invalid) id is -1
4304			// bit 30 - object "type" (see above enum)
4305			// bit 29-16 - ServerLib default object id range
4306			// bit 15-0 - application id range
4307			// identification
4308			virtual int GetObjectId();
4309		};
4310	//--------------------------------------------------------------------------------
4311	class CSystemObjectList : public CLockedList<CSystemObject*, CSystemObject*>
4312		{
4313		public:
4314			CSystemObjectList(int nBlock = 10);
4315			virtual ~CSystemObjectList();
4316			POSITION Find(CSystemObject*, POSITION = NULL) const;
4317		};
4318	/*
4319	//--------------------------------------------------------------------------------
4320	extern void AFXAPI DestructElements(CSystemObject** pElements, int nCount);
4321	*/
4322	#endif // !defined(AFX_SYSTEMOBJECT_H__9F10BA26_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: Resource.hYYHEY

4323	//{{NO_DEPENDENCIES}}
4324	// Microsoft Visual C++ generated include file.
4325	// Used by TESTAPP.RC
4326	//
4327	#define IDR_MAINFRAME					128
4328	#define IDD_TESTAPP_DIALOG				102
4329	#define IDP_SOCKETS_INIT_FAILED			103
4330	// Next default values for new objects
4331	//
4332	#ifdef APSTUDIO_INVOKED
4333	#ifndef APSTUDIO_READONLY_SYMBOLS
4334	#define _APS_NEXT_RESOURCE_VALUE	129
4335	#define _APS_NEXT_CONTROL_VALUE		1000
4336	#define _APS_NEXT_SYMED_VALUE		101
4337	#define _APS_NEXT_COMMAND_VALUE		32771
4338	#endif
4339	#endif
ZZHEYXXHEYFile: StdAfx.cppYYHEY

4340	// stdafx.cpp : source file that includes just the standard includes
4341	//	TestApp.pch will be the pre-compiled header
4342	//	stdafx.obj will contain the pre-compiled type information
4343	#include "stdafx.h"
ZZHEYXXHEYFile: StdAfx.hYYHEY

4344	// stdafx.h : include file for standard system include files,
4345	//  or project specific include files that are used frequently, but
4346	//      are changed infrequently
4347	//
4348	#if !defined(AFX_STDAFX_H__0CDE20F9_7790_428D_B97E_3E76562BA165__INCLUDED_)
4349	#define AFX_STDAFX_H__0CDE20F9_7790_428D_B97E_3E76562BA165__INCLUDED_
4350	#if _MSC_VER > 1000
4351	#pragma once
4352	#endif // _MSC_VER > 1000
4353	#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
4354	#include <afxwin.h>         // MFC core and standard components
4355	#include <afxext.h>         // MFC extensions
4356	#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
4357	#ifndef _AFX_NO_AFXCMN_SUPPORT
4358	#include <afxcmn.h>			// MFC support for Windows Common Controls
4359	#endif // _AFX_NO_AFXCMN_SUPPORT
4360	#include <afxsock.h>		// MFC socket extensions
4361	//{{AFX_INSERT_LOCATION}}
4362	// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
4363	#endif // !defined(AFX_STDAFX_H__0CDE20F9_7790_428D_B97E_3E76562BA165__INCLUDED_)
ZZHEYXXHEYFile: TestApp.cppYYHEY

4364	// TestApp.cpp : Defines the class behaviors for the application.
4365	//
4366	#include "stdafx.h"
4367	#include "TestApp.h"
4368	#include "TestAppDlg.h"
4369	#ifdef _DEBUG
4370	#define new DEBUG_NEW
4371	#undef THIS_FILE
4372	static char THIS_FILE[] = __FILE__;
4373	#endif
4374	/////////////////////////////////////////////////////////////////////////////
4375	// CTestAppApp
4376	BEGIN_MESSAGE_MAP(CTestAppApp, CWinApp)
4377		//{{AFX_MSG_MAP(CTestAppApp)
4378			// NOTE - the ClassWizard will add and remove mapping macros here.
4379			//    DO NOT EDIT what you see in these blocks of generated code!
4380		//}}AFX_MSG
4381		ON_COMMAND(ID_HELP, CWinApp::OnHelp)
4382	END_MESSAGE_MAP()
4383	/////////////////////////////////////////////////////////////////////////////
4384	// CTestAppApp construction
4385	CTestAppApp::CTestAppApp()
4386	{
4387		// TODO: add construction code here,
4388		// Place all significant initialization in InitInstance
4389	}
4390	/////////////////////////////////////////////////////////////////////////////
4391	// The one and only CTestAppApp object
4392	CTestAppApp theApp;
4393	/////////////////////////////////////////////////////////////////////////////
4394	// CTestAppApp initialization
4395	#include <ChangeNotificationSubSystem.h>
4396	#include <ChangeNotificationObj.h>
4397	class CTestThread : public CThreadObject
4398		{
4399		public:
4400			CTestThread();
4401			virtual void OnMessage(UINT, WPARAM, LPARAM);
4402		};
4403	CTestThread::CTestThread()
4404	: CThreadObject(NULL)
4405		{
4406		}
4407	void CTestThread::OnMessage(UINT nMsg, WPARAM pParam, LPARAM)
4408		{
4409		if(nMsg == CChangeNotificationSubSystem::MsgChangeNotify)
4410			{
4411			CFileChangeNotificationObj* pObj = (CFileChangeNotificationObj*) pParam;
4412	//		TRACE("CHANGE: %s ", pObj->GetActionName());
4413			if(pObj->m_nAction == FILE_ACTION_RENAMED_NEW_NAME)
4414				TRACE("%s to %s\n", pObj->m_pOldFilename, pObj->m_pFilename);
4415			else
4416				TRACE("%s\n", pObj->m_pFilename);
4417			delete pObj;
4418			}
4419		}
4420	BOOL CTestAppApp::InitInstance()
4421	{
4422		if (!AfxSocketInit())
4423		{
4424			AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
4425			return FALSE;
4426		}
4427		CTestThread* pThread = new CTestThread;
4428		pThread->StartThread();
4429		CSystem system;
4430		CChangeNotificationSubSystem sub(&system);
4431		system.SetState(STATE_RUN);
4432		sub.AddWatch("c:\\temp", pThread, CChangeNotificationSubSystem::MsgChangeNotify, true);
4433		CTestAppDlg dlg;
4434		m_pMainWnd = &dlg;
4435		int nResponse = dlg.DoModal();
4436		if (nResponse == IDOK)
4437		{
4438			// TODO: Place code here to handle when the dialog is
4439			//  dismissed with OK
4440		}
4441		else if (nResponse == IDCANCEL)
4442		{
4443			// TODO: Place code here to handle when the dialog is
4444			//  dismissed with Cancel
4445		}
4446		system.SetState(STATE_EXIT);
4447		system.WaitForStateSync();
4448	//	delete pThread;
4449		// Since the dialog has been closed, return FALSE so that we exit the
4450		//  application, rather than start the application's message pump.
4451		return FALSE;
4452	}
ZZHEYXXHEYFile: TestApp.hYYHEY

4453	// TestApp.h : main header file for the TESTAPP application
4454	//
4455	#if !defined(AFX_TESTAPP_H__384EC787_9293_4718_AEA8_E35221B96545__INCLUDED_)
4456	#define AFX_TESTAPP_H__384EC787_9293_4718_AEA8_E35221B96545__INCLUDED_
4457	#if _MSC_VER > 1000
4458	#pragma once
4459	#endif // _MSC_VER > 1000
4460	#ifndef __AFXWIN_H__
4461		#error include 'stdafx.h' before including this file for PCH
4462	#endif
4463	#include "resource.h"		// main symbols
4464	/////////////////////////////////////////////////////////////////////////////
4465	// CTestAppApp:
4466	// See TestApp.cpp for the implementation of this class
4467	//
4468	class CTestAppApp : public CWinApp
4469	{
4470	public:
4471		CTestAppApp();
4472	// Overrides
4473		// ClassWizard generated virtual function overrides
4474		//{{AFX_VIRTUAL(CTestAppApp)
4475		public:
4476		virtual BOOL InitInstance();
4477		//}}AFX_VIRTUAL
4478	// Implementation
4479		//{{AFX_MSG(CTestAppApp)
4480			// NOTE - the ClassWizard will add and remove member functions here.
4481			//    DO NOT EDIT what you see in these blocks of generated code !
4482		//}}AFX_MSG
4483		DECLARE_MESSAGE_MAP()
4484	};
4485	/////////////////////////////////////////////////////////////////////////////
4486	//{{AFX_INSERT_LOCATION}}
4487	// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
4488	#endif // !defined(AFX_TESTAPP_H__384EC787_9293_4718_AEA8_E35221B96545__INCLUDED_)
ZZHEYXXHEYFile: TestAppDlg.cppYYHEY

4489	// TestAppDlg.cpp : implementation file
4490	//
4491	#include "stdafx.h"
4492	#include "TestApp.h"
4493	#include "TestAppDlg.h"
4494	#ifdef _DEBUG
4495	#define new DEBUG_NEW
4496	#undef THIS_FILE
4497	static char THIS_FILE[] = __FILE__;
4498	#endif
4499	/////////////////////////////////////////////////////////////////////////////
4500	// CTestAppDlg dialog
4501	CTestAppDlg::CTestAppDlg(CWnd* pParent /*=NULL*/)
4502		: CDialog(CTestAppDlg::IDD, pParent)
4503	{
4504		//{{AFX_DATA_INIT(CTestAppDlg)
4505			// NOTE: the ClassWizard will add member initialization here
4506		//}}AFX_DATA_INIT
4507		// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
4508		m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
4509	}
4510	void CTestAppDlg::DoDataExchange(CDataExchange* pDX)
4511	{
4512		CDialog::DoDataExchange(pDX);
4513		//{{AFX_DATA_MAP(CTestAppDlg)
4514			// NOTE: the ClassWizard will add DDX and DDV calls here
4515		//}}AFX_DATA_MAP
4516	}
4517	BEGIN_MESSAGE_MAP(CTestAppDlg, CDialog)
4518		//{{AFX_MSG_MAP(CTestAppDlg)
4519		ON_WM_PAINT()
4520		ON_WM_QUERYDRAGICON()
4521		//}}AFX_MSG_MAP
4522	END_MESSAGE_MAP()
4523	/////////////////////////////////////////////////////////////////////////////
4524	// CTestAppDlg message handlers
4525	BOOL CTestAppDlg::OnInitDialog()
4526	{
4527		CDialog::OnInitDialog();
4528		// Set the icon for this dialog.  The framework does this automatically
4529		//  when the application's main window is not a dialog
4530		SetIcon(m_hIcon, TRUE);			// Set big icon
4531		SetIcon(m_hIcon, FALSE);		// Set small icon
4532		// TODO: Add extra initialization here
4533		return TRUE;  // return TRUE  unless you set the focus to a control
4534	}
4535	// If you add a minimize button to your dialog, you will need the code below
4536	//  to draw the icon.  For MFC applications using the document/view model,
4537	//  this is automatically done for you by the framework.
4538	void CTestAppDlg::OnPaint()
4539	{
4540		if (IsIconic())
4541		{
4542			CPaintDC dc(this); // device context for painting
4543			SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);
4544			// Center icon in client rectangle
4545			int cxIcon = GetSystemMetrics(SM_CXICON);
4546			int cyIcon = GetSystemMetrics(SM_CYICON);
4547			CRect rect;
4548			GetClientRect(&rect);
4549			int x = (rect.Width() - cxIcon + 1) / 2;
4550			int y = (rect.Height() - cyIcon + 1) / 2;
4551			// Draw the icon
4552			dc.DrawIcon(x, y, m_hIcon);
4553		}
4554		else
4555		{
4556			CDialog::OnPaint();
4557		}
4558	}
4559	// The system calls this to obtain the cursor to display while the user drags
4560	//  the minimized window.
4561	HCURSOR CTestAppDlg::OnQueryDragIcon()
4562	{
4563		return (HCURSOR) m_hIcon;
4564	}
ZZHEYXXHEYFile: TestAppDlg.hYYHEY

4565	// TestAppDlg.h : header file
4566	//
4567	#if !defined(AFX_TESTAPPDLG_H__11951AFB_8251_4E6D_B1DF_CCD303BC8FC0__INCLUDED_)
4568	#define AFX_TESTAPPDLG_H__11951AFB_8251_4E6D_B1DF_CCD303BC8FC0__INCLUDED_
4569	#if _MSC_VER > 1000
4570	#pragma once
4571	#endif // _MSC_VER > 1000
4572	/////////////////////////////////////////////////////////////////////////////
4573	// CTestAppDlg dialog
4574	class CTestAppDlg : public CDialog
4575	{
4576	// Construction
4577	public:
4578		CTestAppDlg(CWnd* pParent = NULL);	// standard constructor
4579	// Dialog Data
4580		//{{AFX_DATA(CTestAppDlg)
4581		enum { IDD = IDD_TESTAPP_DIALOG };
4582			// NOTE: the ClassWizard will add data members here
4583		//}}AFX_DATA
4584		// ClassWizard generated virtual function overrides
4585		//{{AFX_VIRTUAL(CTestAppDlg)
4586		protected:
4587		virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
4588		//}}AFX_VIRTUAL
4589	// Implementation
4590	protected:
4591		HICON m_hIcon;
4592		// Generated message map functions
4593		//{{AFX_MSG(CTestAppDlg)
4594		virtual BOOL OnInitDialog();
4595		afx_msg void OnPaint();
4596		afx_msg HCURSOR OnQueryDragIcon();
4597		//}}AFX_MSG
4598		DECLARE_MESSAGE_MAP()
4599	};
4600	//{{AFX_INSERT_LOCATION}}
4601	// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
4602	#endif // !defined(AFX_TESTAPPDLG_H__11951AFB_8251_4E6D_B1DF_CCD303BC8FC0__INCLUDED_)
ZZHEYXXHEYFile: ThreadLoadBalancePool.cppYYHEY

4603	//--------------------------------------------------------------------------------
4604	//
4605	// Copyright (c) 2000 @COMPANY
4606	//
4607	// Programming by Rich Schonthal
4608	//
4609	//--------------------------------------------------------------------------------
4610	#include <stdafx.h>
4611	#include "ThreadObjectPoolControlThread.h"
4612	#include "ThreadObjectPool.h"
4613	#include "ThreadObject.h"
4614	//--------------------------------------------------------------------------------
4615	CThreadObject* CThreadLoadBalancePool::GetNextWaiting(DWORD nWait)
4616		{
4617		DWORD nStart = CTime::GetCurrentTime().GetTime();
4618		CThreadObject* pThread = NULL;
4619		CSyncObject* pLocks[2];
4620		pLocks[0] = &GetWaitingThreads()->m_mutex;
4621		pLocks[1] = &GetActiveThreads()->m_mutex;
4622		CMultiLock lock(pLocks, 2, false);
4623		for(;;)
4624			{
4625			// have we waited long enough?
4626			if(nWait != INFINITE && (DWORD) CTime::GetCurrentTime().GetTime() > nStart + nWait)
4627				return NULL;
4628			if(lock.Lock() == -1)
4629				return NULL;
4630			// no threads available?
4631			if(GetWaitingThreads()->GetCount() == 0)
4632				{
4633				ASSERT(GetMaxSize() != 0);
4634				// have we maxed out the pool?
4635				if(GetActiveThreads()->GetCount() == (long) GetMaxSize())
4636					{
4637					lock.Unlock();
4638					::Sleep(100);
4639					continue;
4640					}
4641				lock.Unlock();
4642				::Sleep(100);
4643				// cant add any more?
4644				if(! IncreasePool())
4645					continue;
4646				if(lock.Lock() == -1)
4647					return NULL;
4648				}
4649			break;
4650			}
4651		POSITION pos = GetWaitingThreads()->GetHeadPosition();
4652		if(pos == NULL)
4653			return NULL;
4654		pThread = GetWaitingThreads()->GetAt(pos);
4655		GetWaitingThreads()->RemoveAt(pos);
4656		GetWaitingThreads()->AddTail(pThread);
4657		lock.Unlock();
4658		// here's the big difference between this function and the
4659		// version in the ThreadPool
4660		// the difference is that here we dont move the thread to the active list
4661		// it will move itself when it's load is "full"
4662		pThread->OnActivate();
4663		return pThread;
4664		}
4665	//--------------------------------------------------------------------------------
4666	bool CThreadLoadBalancePool::ReleaseActive(CThreadObject* pThread)
4667		{
4668		return SetThreadWaiting(pThread);
4669		}
4670	//--------------------------------------------------------------------------------
4671	bool CThreadLoadBalancePool::SetThreadActive(CThreadObject* pThread)
4672		{
4673		CSyncObject* pLocks[2];
4674		pLocks[0] = &GetWaitingThreads()->m_mutex;
4675		pLocks[1] = &GetActiveThreads()->m_mutex;
4676		CMultiLock lock(pLocks, 2, false);
4677		if(lock.Lock() == -1)
4678			return false;
4679		POSITION pos = GetWaitingThreads()->Find(pThread);
4680		if(pos != NULL)
4681			GetWaitingThreads()->RemoveAt(pos);
4682		pos = GetActiveThreads()->Find(pThread);
4683		if(pos != NULL)
4684			GetActiveThreads()->RemoveAt(pos);
4685		pThread->m_bActive = true;
4686		GetActiveThreads()->AddTail(pThread);
4687		return pThread->OnActivate();
4688		}
4689	//--------------------------------------------------------------------------------
4690	bool CThreadLoadBalancePool::SetThreadWaiting(CThreadObject* pThread)
4691		{
4692		CSyncObject* pLocks[2];
4693		pLocks[0] = &GetWaitingThreads()->m_mutex;
4694		pLocks[1] = &GetActiveThreads()->m_mutex;
4695		CMultiLock lock(pLocks, 2, false);
4696		if(lock.Lock() == -1)
4697			return false;
4698		POSITION pos = GetActiveThreads()->Find(pThread);
4699		if(pos != NULL)
4700			GetActiveThreads()->RemoveAt(pos);
4701		pos = GetWaitingThreads()->Find(pThread);
4702		if(pos != NULL)
4703			GetWaitingThreads()->RemoveAt(pos);
4704		pThread->m_bActive = false;
4705		GetWaitingThreads()->AddTail(pThread);
4706		return pThread->OnDeactivate();
4707		}
ZZHEYXXHEYFile: ThreadObject.cppYYHEY

4708	//--------------------------------------------------------------------------------
4709	//
4710	// Copyright (c) 1999 @COMPANY
4711	//
4712	// Programming by Rich Schonthal
4713	//
4714	//--------------------------------------------------------------------------------
4715	//--------------------------------------------------------------------------------
4716	#include "stdafx.h"
4717	#include "ThreadObject.h"
4718	#include "SubSystem.h"
4719	#include "System.h"
4720	#include <ReadLock.h>
4721	#include <Process.h>
4722	//--------------------------------------------------------------------------------
4723	IMPLEMENT_DYNCREATE(CThreadObject, CSystemObject);
4724	//--------------------------------------------------------------------------------
4725	#ifdef _DEBUG
4726	#define new DEBUG_NEW
4727	#undef THIS_FILE
4728	static char THIS_FILE[] = __FILE__;
4729	#endif
4730	//--------------------------------------------------------------------------------
4731	CThreadObject::CThreadObject(CSystemObject* pParent)
4732			: CSystemObject(pParent)
4733			, m_evtThreadBusy(FALSE, TRUE)
4734			, m_hThread(NULL)
4735		{
4736		memset(&m_msgCur, 0, sizeof(MSG));
4737		if(pParent != NULL)
4738			m_pState = pParent->m_pState;
4739		}
4740	//--------------------------------------------------------------------------------
4741	CThreadObject::~CThreadObject()
4742		{
4743		if(m_pParent != NULL && m_pState == m_pParent->m_pState)
4744			m_pState = NULL;
4745		}
4746	//--------------------------------------------------------------------------------
4747	bool CThreadObject::SetParent(CSubSystem* pParent)
4748		{
4749		if(m_pParent != NULL)
4750			return false;
4751		m_pParent = pParent;
4752		if(m_pState == NULL)
4753			m_pState = pParent->m_pState;
4754		return true;
4755		}
4756	//--------------------------------------------------------------------------------
4757	bool CThreadObject::StartThread()
4758		{
4759		if(m_hThread != NULL || m_hThread == INVALID_HANDLE_VALUE)
4760			return false;
4761		m_event.ResetEvent();
4762		// start our control loop
4763		m_hThread = ::CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) StaticMain, this, 0, &m_nThreadId);
4764		if(m_hThread == INVALID_HANDLE_VALUE)
4765			return false;
4766		// wait for StaticMain to start
4767		return ::WaitForSingleObject(m_event, INFINITE) == WAIT_OBJECT_0;
4768		}
4769	//--------------------------------------------------------------------------------
4770	bool CThreadObject::EndThread()
4771		{
4772		if(this == NULL)
4773			return false;
4774		if(m_hThread == NULL || m_hThread == INVALID_HANDLE_VALUE)
4775			return false;
4776		::PostThreadMessage(m_nThreadId, WM_QUIT, 0, 0);
4777		::WaitForSingleObject(m_hThread, INFINITE);
4778		::CloseHandle(m_hThread);
4779		m_hThread = INVALID_HANDLE_VALUE;
4780		return true;
4781		}
4782	//--------------------------------------------------------------------------------
4783	UINT CThreadObject::StaticMain(CThreadObject* that)
4784		{
4785		int nHandCount = 0;
4786		HANDLE handsToWaitFor[2];
4787		// if we're part of a system then we add ourselves as a state client
4788		// so that the subsystem knows how many threads to wait for when
4789		// changing states (for state sync)
4790		CSystemObject* pParent = that->GetParent();
4791		const DWORD nStateWaitId = that->m_pState != NULL ? 0 : (DWORD) -1;
4792		if(that->m_pState != NULL)
4793			{
4794			if(pParent != NULL)
4795				pParent->AddStateClient();
4796			handsToWaitFor[nHandCount++] = that->m_pState->m_evtChanged;
4797			}
4798		HANDLE hTimer = NULL;
4799		// set up the timer that we'll use for the main loop interval
4800		DWORD nSleepTime = that->GetThreadLoopSleepInterval();
4801		DWORD nTimerWaitId;
4802		if(nSleepTime != (DWORD) -1)
4803			{
4804			hTimer = ::CreateWaitableTimer(NULL, FALSE, NULL);
4805			// negative values are relative time - this will make the timers first signal
4806			// happen (almost) immediatly
4807			__int64 nTimerDue = -1;
4808			::SetWaitableTimer(hTimer, (LARGE_INTEGER*) &nTimerDue, nSleepTime, NULL, NULL, FALSE);
4809			nTimerWaitId = nHandCount;
4810			handsToWaitFor[nHandCount++] = hTimer;
4811			}
4812		else
4813			nTimerWaitId = (DWORD) -1;
4814		DWORD nLastState = (DWORD) -1;
4815		bool bInitOk = that->Init();
4816		// signal that the thread is initialized
4817		that->m_event.SetEvent();
4818		if(bInitOk)
4819			TRY
4820				{
4821				for(;;)
4822					{
4823					DWORD nWait = ::MsgWaitForMultipleObjects(nHandCount, handsToWaitFor, FALSE, 20, QS_ALLEVENTS);
4824					// for debugging
4825					if(nWait == WAIT_FAILED || nWait == WAIT_ABANDONED || nWait == WAIT_TIMEOUT)
4826						continue;
4827					if(PeekMessage(&that->m_msgCur, NULL, 0, 0, PM_REMOVE))
4828						{
4829						UINT nMsg = that->m_msgCur.message;
4830						if(nMsg == WM_DESTROY)
4831							that->OnMessage(WM_QUIT, that->m_msgCur.wParam, that->m_msgCur.lParam);
4832						else
4833							that->OnMessage(that->m_msgCur.message, that->m_msgCur.wParam,
4834									that->m_msgCur.lParam);
4835						if(nMsg == WM_QUIT || nMsg == WM_DESTROY)
4836							break;
4837						}
4838					if(nTimerWaitId != (DWORD)-1 && nWait == nTimerWaitId)
4839						{
4840						if(! that->MainLoop())
4841							break;
4842						}
4843					else
4844						if(nStateWaitId != (DWORD)-1 && nWait == nStateWaitId)
4845							{
4846							that->OnStateChange(that->GetState());
4847							if(! that->CheckState())
4848								break;
4849							}
4850					// did the sleep interval change?
4851					if(nSleepTime != that->GetThreadLoopSleepInterval())
4852						{
4853						// if there was a timer, cancel it
4854						if(hTimer != NULL)
4855							{
4856							::CancelWaitableTimer(hTimer);
4857							::CloseHandle(hTimer);
4858							nHandCount--;
4859							}
4860						// get the new sleep interval
4861						nSleepTime = that->GetThreadLoopSleepInterval();
4862						if(nSleepTime != (DWORD) -1)
4863							{
4864							hTimer = ::CreateWaitableTimer(NULL, FALSE, NULL);
4865							// negative values are relative time - this will make the timers first signal
4866							// happen (almost) immediatly
4867							__int64 nTimerDue = -1;
4868							::SetWaitableTimer(hTimer, (LARGE_INTEGER*) &nTimerDue, nSleepTime, NULL, NULL, FALSE);
4869							nTimerWaitId = nHandCount;
4870							handsToWaitFor[nHandCount++] = hTimer;
4871							}
4872						else
4873							{
4874							hTimer = NULL;
4875							nTimerWaitId = (DWORD)-1;
4876							}
4877						}
4878					}
4879				}
4880			CATCH_ALL(e)
4881				{
4882				}
4883			END_CATCH_ALL;
4884		if(hTimer != NULL)
4885			{
4886			::CancelWaitableTimer(hTimer);
4887			::CloseHandle(hTimer);
4888			}
4889		that->Exit(bInitOk);
4890		that->AcknowledgeStateChange();
4891		if(pParent != NULL)
4892			pParent->RemoveStateClient();
4893		UINT nRv = that->GetResultCode();
4894		// basically this is 'delete this' which is kinda a no-no
4895		// but this is the one case i can think of where it's warrented
4896		// this class provides an easy to use thread encapsulation so
4897		// the thread should be able to delete itself, no?
4898		if(that->m_msgCur.message == WM_DESTROY)
4899			delete that;
4900		return nRv;
4901		}
4902	//--------------------------------------------------------------------------------
4903	bool CThreadObject::OnActivate()
4904		{
4905		return true;
4906		}
4907	//--------------------------------------------------------------------------------
4908	bool CThreadObject::OnDeactivate()
4909		{
4910		GetEvent().SetEvent();
4911		return true;
4912		}
4913	//--------------------------------------------------------------------------------
4914	void CThreadObject::OnStateChange(DWORD nState)
4915		{
4916		// if the state is state_stop or higher then we'll
4917		// delay acking it til the thread is ready to exit
4918		if(nState < STATE_STOP)
4919			AcknowledgeStateChange();
4920		}
4921	//--------------------------------------------------------------------------------
4922	void CThreadObject::OnMessage(UINT, WPARAM, LPARAM)
4923		{
4924		return;
4925		}
4926	//--------------------------------------------------------------------------------
4927	DWORD CThreadObject::GetThreadLoopSleepInterval() const
4928		{
4929		// the default is to not have a MainLoop so we return 0
4930		// see StaticMain (waitable timer stuff) for details
4931		return 100;
4932		}
4933	//--------------------------------------------------------------------------------
4934	DWORD CThreadObject::GetPauseWaitSleepInterval() const
4935		{
4936		return 0;
4937		}
4938	//--------------------------------------------------------------------------------
4939	bool CThreadObject::MainLoop()
4940		{
4941		return CheckState();
4942		}
4943	//--------------------------------------------------------------------------------
4944	bool CThreadObject::Init()
4945		{
4946		return true;
4947		}
4948	//--------------------------------------------------------------------------------
4949	void CThreadObject::Exit(bool)
4950		{
4951		}
4952	//--------------------------------------------------------------------------------
4953	void CThreadObject::SetThreadBusy(bool bIsBusy)
4954		{
4955		CSystemObject* pParent = GetParent();
4956		bool bIsPool = pParent != NULL && pParent->IsKindOf(RUNTIME_CLASS(CThreadPoolSubSystem));
4957		if(bIsBusy)
4958			{
4959			if(bIsPool)
4960				((CThreadPoolSubSystem*) pParent)->IncBusyThreadCount();
4961			m_evtThreadBusy.SetEvent();
4962			OnActivate();
4963			}
4964		else
4965			{
4966			if(bIsPool)
4967				((CThreadPoolSubSystem*) pParent)->DecBusyThreadCount();
4968			m_evtThreadBusy.ResetEvent();
4969			OnDeactivate();
4970			}
4971		}
4972	//--------------------------------------------------------------------------------
4973	bool CThreadObject::CheckState()
4974		{
4975		switch(GetState())
4976			{
4977			default:
4978			case STATE_INIT:
4979			case STATE_RUN:
4980			case STATE_PAUSE:
4981				return true;
4982			case STATE_UNKNOWN:
4983			case STATE_ERROR:
4984			case STATE_EXIT:
4985			case STATE_STOP:
4986				return false;
4987			}
4988		}
4989	//--------------------------------------------------------------------------------
4990	CSystemObject* CThreadObject::GetParentFromClass(const CRuntimeClass* pClass)
4991		{
4992		if(m_pParent == NULL)
4993			return NULL;
4994		for(CSystemObject* pObj = m_pParent; pObj != NULL; )
4995			{
4996			CRuntimeClass* pCurClass = pObj->GetRuntimeClass();
4997			if(pCurClass == NULL)
4998				return NULL;
4999			if(pCurClass->IsDerivedFrom(pClass))
5000				return pObj;
5001			pObj = pObj->m_pParent;
5002			}
5003		return NULL;
5004		}
ZZHEYXXHEYFile: ThreadObject.hYYHEY

5005	//--------------------------------------------------------------------------------
5006	//
5007	// Copyright (c) 1999 @COMPANY
5008	//
5009	// Programming by Rich Schonthal
5010	//
5011	//--------------------------------------------------------------------------------
5012	#if !defined(AFX_THREADOBJECT_H__9F10BA23_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_)
5013	#define AFX_THREADOBJECT_H__9F10BA23_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_
5014	//--------------------------------------------------------------------------------
5015	#if _MSC_VER > 1000
5016	#pragma once
5017	#endif // _MSC_VER > 1000
5018	//--------------------------------------------------------------------------------
5019	#include "result.h"
5020	#include "SystemObject.h"
5021	//--------------------------------------------------------------------------------
5022	class CSystem;
5023	class CSubSystem;
5024	//--------------------------------------------------------------------------------
5025	class CThreadObject : public CSystemObject
5026		{
5027		DECLARE_DYNCREATE(CThreadObject);
5028		friend class CThreadPoolSubSystem;
5029		protected:
5030			HANDLE m_hThread;
5031			DWORD m_nThreadId;
5032			MSG m_msgCur;
5033			CEvent m_evtThreadBusy;
5034		protected:
5035			CThreadObject(CSystemObject* = NULL);
5036			static UINT StaticMain(CThreadObject*);
5037			// override if you want a different or dynamic sleep interval
5038			virtual DWORD GetThreadLoopSleepInterval() const;
5039			virtual DWORD GetPauseWaitSleepInterval() const;
5040			// derived mainloops return true to continue looping
5041			// or false to exit - use CResult::SetResultCode for exit code
5042			// use MainLoop in your derived thread when you want to run in a continuous loop
5043			// (see StaticMain)
5044			virtual bool MainLoop();
5045			// use OnMessage when you want your thread to be message based
5046			// (see StaticMain)
5047			virtual void OnMessage(UINT, WPARAM, LPARAM);
5048			// called only when this thread is part of a thread pool
5049			virtual bool OnActivate();
5050			virtual bool OnDeactivate();
5051			// called when the state changes
5052			virtual void OnStateChange(DWORD);
5053			// if init returns false, the main loop is never called
5054			// no events are process, and Exit is called with param false
5055			virtual bool Init();
5056			virtual void Exit(bool bInitOk);
5057			// checks the current state
5058			// returns true if the thread should continue running
5059			// (ie the state != STATE_STOP and != STATE_ERROR
5060			virtual bool CheckState();
5061			// returns m_bActive
5062			bool IsActive() const;
5063			bool SetThreadPriority(int nPriority);
5064			void SetThreadBusy(bool bIsBusy);
5065			bool SetParent(CSubSystem*);
5066		public:
5067			virtual ~CThreadObject();
5068			// always call after allocation
5069			virtual bool StartThread();
5070			bool EndThread();
5071			CEvent& GetEvent();
5072			// posts a message to this thread
5073			virtual bool PostMessage(UINT, WPARAM = 0, LPARAM = 0);
5074			// waits until the thread handle signals
5075			// use to wait for the thread to exit
5076			bool WaitForThreadExit(DWORD = INFINITE);
5077			// some helpful functions
5078			HANDLE GetThreadHandle();
5079			DWORD GetThreadId();
5080			int GetThreadPriority();
5081			bool IsThreadBusy(DWORD nWait = 0);
5082		protected:
5083			CSystemObject* GetParentFromClass(const CRuntimeClass*);
5084		};
5085	//--------------------------------------------------------------------------------
5086	template<class T_SYSTEM, class T_SUBSYSTEM>
5087	class CTypedThreadObject : public CThreadObject
5088		{
5089		private:
5090			// cache for GetSystem and GetSubSystem
5091			T_SYSTEM* m_pSystem;
5092			T_SUBSYSTEM* m_pSubSystem;
5093		public:
5094			CTypedThreadObject(T_SUBSYSTEM* = NULL);
5095			virtual ~CTypedThreadObject();
5096			T_SYSTEM* GetSystem();
5097			T_SUBSYSTEM* GetSubSystem();
5098		};
5099	//--------------------------------------------------------------------------------
5100	template<class T_SYSTEM, class T_SUBSYSTEM>
5101	inline CTypedThreadObject<T_SYSTEM, T_SUBSYSTEM>::CTypedThreadObject(T_SUBSYSTEM* pSys)
5102		: CThreadObject((CSystemObject*) pSys), m_pSystem(NULL), m_pSubSystem(NULL)  {}
5103	template<class T_SYSTEM, class T_SUBSYSTEM>
5104	inline CTypedThreadObject<T_SYSTEM, T_SUBSYSTEM>::~CTypedThreadObject() {}
5105	template<class T_SYSTEM, class T_SUBSYSTEM>
5106	inline T_SYSTEM* CTypedThreadObject<T_SYSTEM, T_SUBSYSTEM>::GetSystem()
5107		{
5108		if(m_pSystem != NULL)
5109			return m_pSystem;
5110		m_pSystem = (T_SYSTEM*) GetParentFromClass(RUNTIME_CLASS(CSystem));
5111		return m_pSystem;
5112		}
5113	template<class T_SYSTEM, class T_SUBSYSTEM>
5114	inline T_SUBSYSTEM* CTypedThreadObject<T_SYSTEM, T_SUBSYSTEM>::GetSubSystem()
5115		{
5116		if(m_pSubSystem != NULL)
5117			return m_pSubSystem;
5118		m_pSubSystem = (T_SUBSYSTEM*) GetParentFromClass(RUNTIME_CLASS(CSubSystem));
5119		return m_pSubSystem;
5120		}
5121	//--------------------------------------------------------------------------------
5122	inline bool CThreadObject::PostMessage(UINT nMsg, WPARAM wParam, LPARAM lParam)
5123		{ return ::PostThreadMessage(m_nThreadId, nMsg, wParam, lParam) != FALSE; }
5124	inline HANDLE CThreadObject::GetThreadHandle() { return m_hThread; }
5125	inline DWORD CThreadObject::GetThreadId() {	return m_nThreadId; }
5126	inline CEvent& CThreadObject::GetEvent() { return m_event; }
5127	inline bool CThreadObject::WaitForThreadExit(DWORD nWait)
5128		{
5129		if(m_hThread == NULL || m_hThread == INVALID_HANDLE_VALUE)
5130			return true;
5131		return ::WaitForSingleObject(m_hThread, nWait) == WAIT_OBJECT_0;
5132		}
5133	inline bool CThreadObject::SetThreadPriority(int nPriority) { return ::SetThreadPriority(m_hThread, nPriority) != 0; }
5134	inline int CThreadObject::GetThreadPriority() { return ::GetThreadPriority(m_hThread); }
5135	inline bool CThreadObject::IsThreadBusy(DWORD nWait) { return ::WaitForSingleObject(m_evtThreadBusy, nWait) == WAIT_OBJECT_0; }
5136	//--------------------------------------------------------------------------------
5137	//{{AFX_INSERT_LOCATION}}
5138	// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
5139	#endif // !defined(AFX_THREADOBJECT_H__9F10BA23_835B_11D3_B0D3_00A0CC271D0D__INCLUDED_)
ZZHEYXXHEYFile: ThreadObjectPool.cppYYHEY

5140	//--------------------------------------------------------------------------------
5141	//
5142	// Copyright (c) 2000 @COMPANY
5143	//
5144	// Programming by Rich Schonthal
5145	//
5146	//--------------------------------------------------------------------------------
5147	#include "stdafx.h"
5148	#include "ThreadObjectPoolControlThread.h"
5149	#include "ThreadObjectPool.h"
5150	#include "ThreadObject.h"
5151	//--------------------------------------------------------------------------------
5152	CThreadObjectPool::CThreadObjectPool(DWORD nFlags, DWORD nMaxSize, DWORD nMaxWaiting, DWORD nCleanUpInterval)
5153			: m_nFlags(nFlags)
5154			, m_nMaxSize(nMaxSize)
5155			, m_nMaxWaiting(nMaxWaiting)
5156			, m_nCleanUpInterval(nCleanUpInterval)
5157		{
5158		m_pActiveThreads = new CThreadObList;
5159		m_pWaitingThreads = new CThreadObList;
5160		if(m_nCleanUpInterval > 0)
5161			{
5162			m_pControlThread = new CThreadObjectPoolControlThread(this);
5163			m_pControlThread->StartThread();
5164			}
5165		else
5166			m_pControlThread = NULL;
5167		}
5168	//--------------------------------------------------------------------------------
5169	CThreadObjectPool::~CThreadObjectPool()
5170		{
5171		m_pControlThread->EndThread();
5172		delete m_pControlThread;
5173		m_pControlThread = NULL;
5174		if(m_pActiveThreads != NULL)
5175			m_pActiveThreads->WaitForAllToExit(30000);
5176		if(m_pWaitingThreads != NULL)
5177			m_pWaitingThreads->WaitForAllToExit(30000);
5178		delete m_pActiveThreads;
5179		delete m_pWaitingThreads;
5180		}
5181	//--------------------------------------------------------------------------------
5182	DWORD CThreadObjectPool::GetFlags() const
5183		{
5184		return m_nFlags;
5185		}
5186	//--------------------------------------------------------------------------------
5187	void CThreadObjectPool::SetFlags(DWORD nFlags)
5188		{
5189		m_nFlags = nFlags;
5190		}
5191	//--------------------------------------------------------------------------------
5192	DWORD CThreadObjectPool::GetMaxSize() const
5193		{
5194		return m_nMaxSize;
5195		}
5196	//--------------------------------------------------------------------------------
5197	void CThreadObjectPool::SetMaxSize(DWORD nSize)
5198		{
5199		m_nMaxSize = nSize;
5200		}
5201	//--------------------------------------------------------------------------------
5202	DWORD CThreadObjectPool::GetMaxWaiting() const
5203		{
5204		return m_nMaxWaiting;
5205		}
5206	//--------------------------------------------------------------------------------
5207	void CThreadObjectPool::SetMaxWaiting(DWORD nSize)
5208		{
5209		m_nMaxWaiting = nSize;
5210		}
5211	//--------------------------------------------------------------------------------
5212	DWORD CThreadObjectPool::GetCleanUpInterval() const
5213		{
5214		return m_nCleanUpInterval;
5215		}
5216	//--------------------------------------------------------------------------------
5217	void CThreadObjectPool::SetCleanUpInterval(DWORD nInterval)
5218		{
5219		if(nInterval > 0 && m_pControlThread == NULL)
5220			{
5221			m_pControlThread = new CThreadObjectPoolControlThread(this);
5222			m_pControlThread->StartThread();
5223			}
5224		else
5225			if(nInterval == 0 && m_pControlThread != NULL)
5226				{
5227				m_pControlThread->EndThread();
5228				delete m_pControlThread;
5229				m_pControlThread = NULL;
5230				}
5231		m_nCleanUpInterval = nInterval;
5232		}
5233	//--------------------------------------------------------------------------------
5234	CThreadObList* CThreadObjectPool::GetActiveThreads() const
5235		{
5236		return m_pActiveThreads;
5237		}
5238	//--------------------------------------------------------------------------------
5239	CThreadObList* CThreadObjectPool::GetWaitingThreads() const
5240		{
5241		return m_pWaitingThreads;
5242		}
5243	//--------------------------------------------------------------------------------
5244	bool CThreadObjectPool::AddThread(CThreadObject* pThread, bool bActive)
5245		{
5246		ASSERT(sizeof(DWORD) == sizeof(long));
5247		bool bRv;
5248		pThread->m_bActive = bActive;
5249		if(bActive)
5250			bRv = GetActiveThreads()->AddTail(pThread) != NULL;
5251		else
5252			bRv = GetWaitingThreads()->AddTail(pThread) != NULL;
5253		if(! bRv)
5254			{
5255			pThread->EndThread();
5256			delete pThread;
5257			}
5258		return bRv;
5259		}
5260	//--------------------------------------------------------------------------------
5261	bool CThreadObjectPool::SetThreadActive(CThreadObject* pThread)
5262		{
5263		CSingleLock lock(&GetActiveThreads()->m_mutex, false);
5264		if(! lock.Lock())
5265			return false;
5266		pThread->m_bActive = true;
5267		GetActiveThreads()->AddHead(pThread);
5268		return pThread->OnActivate();
5269		}
5270	//--------------------------------------------------------------------------------
5271	bool CThreadObjectPool::SetThreadWaiting(CThreadObject* pThread)
5272		{
5273		CSingleLock lock(&GetWaitingThreads()->m_mutex, false);
5274		if(! lock.Lock())
5275			return false;
5276		pThread->m_bActive = false;
5277		if((GetFlags() & TP_KEEPCLEAN) && GetWaitingThreads()->GetCount() >= (int) GetMaxWaiting())
5278			{
5279			pThread->PostMessage(WM_QUIT);
5280			return ::WaitForSingleObject(pThread->GetThreadHandle(), 3000) == WAIT_OBJECT_0;
5281			}
5282		GetWaitingThreads()->AddHead(pThread);
5283		return pThread->OnDeactivate();
5284		}
5285	//--------------------------------------------------------------------------------
5286	CThreadObject* CThreadObjectPool::GetNextWaiting(DWORD nWait)
5287		{
5288		DWORD nStart = CTime::GetCurrentTime().GetTime();
5289		CThreadObject* pThread = NULL;
5290		CSyncObject* pLocks[2];
5291		pLocks[0] = &GetWaitingThreads()->m_mutex;
5292		pLocks[1] = &GetActiveThreads()->m_mutex;
5293		CMultiLock lock(pLocks, 2, false);
5294		for(;;)
5295			{
5296			// have we waited long enough?
5297			if(nWait != INFINITE && (DWORD) CTime::GetCurrentTime().GetTime() > nStart + nWait)
5298				return NULL;
5299			if(lock.Lock() == -1)
5300				return NULL;
5301			// no threads available?
5302			if(GetWaitingThreads()->GetCount() == 0)
5303				{
5304				ASSERT(GetMaxSize() != 0);
5305				// have we maxed out the pool?
5306				if(GetActiveThreads()->GetCount() == (long) GetMaxSize())
5307					{
5308					lock.Unlock();
5309					::Sleep(100);
5310					continue;
5311					}
5312				lock.Unlock();
5313				::Sleep(100);
5314				// cant add any more?
5315				if(! IncreasePool())
5316					continue;
5317				if(lock.Lock() == -1)
5318					return NULL;
5319				}
5320			break;
5321			}
5322		POSITION pos = GetWaitingThreads()->GetHeadPosition();
5323		if(pos == NULL)
5324			return NULL;
5325		pThread = GetWaitingThreads()->GetAt(pos);
5326		GetWaitingThreads()->RemoveAt(pos);
5327		lock.Unlock();
5328		SetThreadActive(pThread);
5329		return pThread;
5330		}
5331	//--------------------------------------------------------------------------------
5332	bool CThreadObjectPool::IncreasePool()
5333		{
5334		return false;
5335		}
5336	//--------------------------------------------------------------------------------
5337	bool CThreadObjectPool::CanIncreasePool() const
5338		{
5339		return true;
5340		}
5341	//--------------------------------------------------------------------------------
5342	bool CThreadObjectPool::ReleaseActive(CThreadObject* pThread)
5343		{
5344		CSyncObject* pLocks[2];
5345		pLocks[0] = &GetWaitingThreads()->m_mutex;
5346		pLocks[1] = &GetActiveThreads()->m_mutex;
5347		CMultiLock lock(pLocks, 2, false);
5348		if(lock.Lock() == -1)
5349			return false;
5350		pThread->m_bActive = false;
5351		POSITION pos = GetActiveThreads()->Find(pThread);
5352		if(pos != NULL)
5353			GetActiveThreads()->RemoveAt(pos);
5354		pos = GetWaitingThreads()->Find(pThread);
5355		if((GetFlags() & TP_KEEPCLEAN) && GetWaitingThreads()->GetCount() >= (int) GetMaxWaiting())
5356			{
5357			if(pos != NULL)
5358				GetWaitingThreads()->RemoveAt(pos);
5359			lock.Unlock();
5360			// WM_DESTROY will cause the thread to exit, as if it received WM_QUIT
5361			// and then it will delete itself
5362			pThread->PostMessage(WM_DESTROY);
5363			return true;
5364			}
5365		if(pos == NULL)
5366			GetWaitingThreads()->AddTail(pThread);
5367		lock.Unlock();
5368		return pThread->OnDeactivate();
5369		}
ZZHEYXXHEYFile: ThreadObjectPool.hYYHEY

5370	//--------------------------------------------------------------------------------
5371	//
5372	// Copyright (c) 2000 @COMPANY
5373	//
5374	// Programming by Rich Schonthal
5375	//
5376	//--------------------------------------------------------------------------------
5377	#ifndef _THREADPOOLOBJECT_H_
5378	#define _THREADPOOLOBJECT_H_
5379	//--------------------------------------------------------------------------------
5380	#include <ReadWriteObject.h>
5381	class CThreadObList;
5382	class CThreadObject;
5383	class CThreadObjectPoolControlThread;
5384	//--------------------------------------------------------------------------------
5385	class CThreadObjectPool
5386		{
5387		public:
5388			enum
5389				{
5390				// set to keep the waiting list clean
5391				// ie when setting a thread to waiting, the max waiting count is checked
5392				// if moving a thread to the waiting list will make waitingcount > maxwaiting
5393				// then the thread is terminated instead of being moved to the waiting list
5394				TP_KEEPCLEAN = 0x00000001
5395				};
5396		private:
5397			CThreadObjectPoolControlThread* m_pControlThread;
5398			CThreadObList* m_pActiveThreads;
5399			CThreadObList* m_pWaitingThreads;
5400			DWORD m_nFlags;
5401			// the total max size of the pool
5402			DWORD m_nMaxSize;
5403			// max allowed to be waiting
5404			DWORD m_nMaxWaiting;
5405			// # of miliseconds between size checks
5406			DWORD m_nCleanUpInterval;
5407		public:
5408			CThreadObjectPool(DWORD nFlags = 0, DWORD nMaxSize = 0, DWORD nMaxWaiting = 0, DWORD nCleanUpInterval = 0);
5409			virtual ~CThreadObjectPool();
5410			// thread pool stuff
5411			// returns ptr to active thread list
5412			CThreadObList* GetActiveThreads() const;
5413			// returns ptr to waiting thread list
5414			CThreadObList* GetWaitingThreads() const;
5415			DWORD GetFlags() const;
5416			void SetFlags(DWORD);
5417			DWORD GetMaxSize() const;
5418			void SetMaxSize(DWORD);
5419			DWORD GetMaxWaiting() const;
5420			void SetMaxWaiting(DWORD);
5421			DWORD GetCleanUpInterval() const;
5422			void SetCleanUpInterval(DWORD);
5423			// called when there are no waiting threads
5424			// and one is requested
5425			virtual bool IncreasePool();
5426			// called to determine if more threads can be allocated
5427			virtual bool CanIncreasePool() const;
5428		public:
5429			// adds to the active thread list
5430			virtual bool SetThreadActive(CThreadObject*);
5431			// adds to the waiting thread list
5432			virtual bool SetThreadWaiting(CThreadObject*);
5433			// removes a thread from the waiting list
5434			// adds it to the active list
5435			// and returns a pointer to it
5436			// calls IncreasePool if the active pool is empty
5437			// returns NULL if there are no available waiting threads
5438			// and IncreasePool failed to add some
5439			virtual CThreadObject* GetNextWaiting(DWORD = INFINITE);
5440			// removes a thread from the active list
5441			// puts it back into the waiting list
5442			virtual bool ReleaseActive(CThreadObject*);
5443			// adds a thread to the thread list
5444			virtual bool AddThread(CThreadObject*, bool bActive = false);
5445		};
5446	//--------------------------------------------------------------------------------
5447	class CThreadLoadBalancePool : public CThreadObjectPool
5448		{
5449		public:
5450			virtual CThreadObject* GetNextWaiting(DWORD = INFINITE);
5451			virtual bool ReleaseActive(CThreadObject*);
5452			virtual bool SetThreadActive(CThreadObject*);
5453			virtual bool SetThreadWaiting(CThreadObject*);
5454		};
5455	#endif // _THREADPOOLOBJECT_H_
ZZHEYXXHEYFile: ThreadObjectPoolControlThread.cppYYHEY

5456	//--------------------------------------------------------------------------------
5457	//
5458	// Copyright (c) 2000 @COMPANY
5459	//
5460	// Programming by Rich Schonthal
5461	//
5462	//--------------------------------------------------------------------------------
5463	#include "stdafx.h"
5464	#include "ThreadObjectPoolControlThread.h"
5465	#include "ThreadObjectPool.h"
5466	//--------------------------------------------------------------------------------
5467	CThreadObjectPoolControlThread::CThreadObjectPoolControlThread(CThreadObjectPool* pPool)
5468			: CThreadObject(NULL)
5469			, m_pPool(pPool)
5470		{
5471		m_ctLastCheck = CTime::GetCurrentTime();
5472		}
5473	//--------------------------------------------------------------------------------
5474	CThreadObjectPoolControlThread::~CThreadObjectPoolControlThread()
5475		{
5476		}
5477	//--------------------------------------------------------------------------------
5478	CThreadObjectPool* CThreadObjectPoolControlThread::GetPool() const
5479		{
5480		return m_pPool;
5481		}
5482	//--------------------------------------------------------------------------------
5483	bool CThreadObjectPoolControlThread::MainLoop()
5484		{
5485		CTime ctNow(CTime::GetCurrentTime());
5486		// is it time to check the thread pool?
5487		if(m_ctLastCheck + GetPool()->GetCleanUpInterval() < ctNow)
5488			{
5489			// 'now' is the last time the pool was checked
5490			m_ctLastCheck = ctNow;
5491			// attempt to lock the thread lists
5492			CSyncObject* locks[2];
5493			locks[0] = &GetPool()->GetWaitingThreads()->m_mutex;
5494			locks[1] = &GetPool()->GetActiveThreads()->m_mutex;
5495			CMultiLock lock(locks, 2, false);
5496			if(! lock.Lock(3000))
5497				return true;
5498			int nMax = (int) GetPool()->GetMaxWaiting();
5499			// are there too many waiting threads?
5500			while(GetPool()->GetWaitingThreads()->GetCount() > nMax)
5501				{
5502				POSITION pos = GetPool()->GetWaitingThreads()->GetHeadPosition();
5503				CThreadObject* pThread = GetPool()->GetWaitingThreads()->GetAt(pos);
5504				pThread->EndThread();
5505				delete pThread;
5506				GetPool()->GetWaitingThreads()->RemoveAt(pos);
5507				}
5508			}
5509		return true;
5510		}
ZZHEYXXHEYFile: ThreadObjectPoolControlThread.hYYHEY

5511	//--------------------------------------------------------------------------------
5512	//
5513	// Copyright (c) 2000 @COMPANY
5514	//
5515	// Programming by Rich Schonthal
5516	//
5517	//--------------------------------------------------------------------------------
5518	#if !defined(AFX_THREADOBJECTPOOLCONTROLTHREAD_H__499C63A4_DD70_11D3_AF12_005004A1C5F3__INCLUDED_)
5519	#define AFX_THREADOBJECTPOOLCONTROLTHREAD_H__499C63A4_DD70_11D3_AF12_005004A1C5F3__INCLUDED_
5520	//--------------------------------------------------------------------------------
5521	#include "ThreadObject.h"
5522	class CThreadObjectPool;
5523	//--------------------------------------------------------------------------------
5524	class CThreadObjectPoolControlThread : public CThreadObject
5525		{
5526		private:
5527			CThreadObjectPool* m_pPool;
5528			CTime m_ctLastCheck;
5529		public:
5530			CThreadObjectPoolControlThread(CThreadObjectPool*);
5531			virtual ~CThreadObjectPoolControlThread();
5532			virtual bool MainLoop();
5533			CThreadObjectPool* GetPool() const;
5534		};
5535	#endif // !defined(AFX_THREADOBJECTPOOLCONTROLTHREAD_H__499C63A4_DD70_11D3_AF12_005004A1C5F3__INCLUDED_)
ZZHEYXXHEYFile: ThreadPoolSubSystem.cppYYHEY

5536	//--------------------------------------------------------------------------------
5537	//
5538	// Copyright (c) 2000 @COMPANY
5539	//
5540	// Programming by Rich Schonthal
5541	//
5542	//--------------------------------------------------------------------------------
5543	#include "stdafx.h"
5544	#include "SubSystem.h"
5545	#include "ThreadObject.h"
5546	#include "System.h"
5547	#include <ReadLock.h>
5548	//--------------------------------------------------------------------------------
5549	IMPLEMENT_DYNAMIC(CThreadPoolSubSystem, CSubSystem)
5550	//--------------------------------------------------------------------------------
5551	CThreadPoolSubSystem::CThreadPoolSubSystem(CSystem* pParent)
5552			: CSubSystem(pParent)
5553			, m_nBusyThreadCount(0)
5554			, m_nProcessorCount(0)
5555		{
5556		}
5557	//--------------------------------------------------------------------------------
5558	CThreadPoolSubSystem::~CThreadPoolSubSystem()
5559		{
5560		CWriteLock lock(&m_threads);
5561		if(m_threads.GetCount() != 0)
5562			{
5563			for(POSITION pos = m_threads.GetHeadPosition(); pos != NULL; )
5564				{
5565				CThreadObject* pThread = m_threads.GetNext(pos);
5566				pThread->EndThread();
5567				delete pThread;
5568				}
5569			}
5570		}
5571	//--------------------------------------------------------------------------------
5572	CThreadObject* CThreadPoolSubSystem::CreateThread(CRuntimeClass* pRuntime)
5573		{
5574		if(pRuntime == NULL)
5575			return NULL;
5576		CThreadObject* pThread = (CThreadObject*) pRuntime->CreateObject();
5577		if(pThread == NULL)
5578			return NULL;
5579		pThread->SetParent(this);
5580		return pThread;
5581		}
5582	//--------------------------------------------------------------------------------
5583	bool CThreadPoolSubSystem::WaitForAllToExit(DWORD nWait)
5584		{
5585		CReadLock lock(&m_threads, false);
5586		if(! lock.Lock())
5587			return false;
5588		// get all the thread's handles so we can wait for them to signal
5589		int nCount = m_threads.GetCount();
5590		HANDLE* pHands = new HANDLE[nCount];
5591		POSITION pos = m_threads.GetHeadPosition();
5592		for(int i = 0; pos != NULL; i++)
5593			pHands[i] = m_threads.GetNext(pos)->GetThreadHandle();
5594		DWORD nResult = (nCount > 0) ? ::WaitForMultipleObjects(nCount, pHands, TRUE, nWait) : 0;
5595		delete[] pHands;
5596		return nResult >= WAIT_OBJECT_0 && nResult < WAIT_OBJECT_0 + nCount;
5597		}
5598	//--------------------------------------------------------------------------------
5599	bool CThreadPoolSubSystem::PostMessage(UINT nMsg, WPARAM wparam, LPARAM lparam)
5600		{
5601		CReadLock lock(&m_threads);
5602		if(m_threads.GetCount() == 0)
5603			return false;
5604		for(POSITION pos = m_threads.GetHeadPosition(); pos != NULL; )
5605			m_threads.GetNext(pos)->PostMessage(nMsg, wparam, lparam);
5606		return true;
5607		}
5608	//--------------------------------------------------------------------------------
5609	bool CThreadPoolSubSystem::PostNextThreadMessage(UINT nMsg, WPARAM wparam, LPARAM lparam)
5610		{
5611		CWriteLock lock(&m_threads);
5612		int nCount = m_threads.GetCount();
5613		if(nCount == 0 || nCount == m_nBusyThreadCount)
5614			return false;
5615		for(;;)
5616			{
5617			CThreadObject* pThread = m_threads.GetNextAndRequeue();
5618			if(pThread->IsThreadBusy(20))
5619				continue;
5620			return pThread->PostMessage(nMsg, wparam, lparam);
5621			}
5622		}
5623	//--------------------------------------------------------------------------------
5624	bool CThreadPoolSubSystem::AddThread(CRuntimeClass* pClass, int nCount)
5625		{
5626		if(nCount == 0)
5627			return false;
5628		// add a thread for each processor in the system
5629		if(nCount == -1)
5630			{
5631			if(m_nProcessorCount != 0)
5632				nCount = m_nProcessorCount;
5633			else
5634				{
5635				SYSTEM_INFO info;
5636				::GetSystemInfo(&info);
5637				nCount = m_nProcessorCount = info.dwNumberOfProcessors;
5638				}
5639			}
5640		for(int i = 0; i < nCount; i++)
5641			{
5642			CThreadObject* pThread = CreateThread(pClass);
5643			if(pThread == NULL)
5644				return false;
5645			pThread->StartThread();
5646			m_threads.Add(pThread);
5647			}
5648		return true;
5649		}
5650	//--------------------------------------------------------------------------------
5651	void CThreadPoolSubSystem::AddThread(CThreadObject* pThread)
5652		{
5653		if(pThread == NULL)
5654			return;
5655		pThread->StartThread();
5656		m_threads.Add(pThread);
5657		}
ZZHEYXXHEYFile: WaitLen.hYYHEY

5658	//--------------------------------------------------------------------------------
5659	//
5660	// Copyright (c) 1999 @COMPANY
5661	//
5662	// Programming by Rich Schonthal
5663	//
5664	//--------------------------------------------------------------------------------
5665	#ifndef _WAITLEN_H_
5666	#define _WAITLEN_H_
5667	// max # of miliseconds SetState will wait to lock m_nState (via m_mutex)
5668	#define WAITLEN_SETSTATE 5000
5669	#endif
ZZHEY